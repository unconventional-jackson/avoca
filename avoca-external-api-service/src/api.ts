/* tslint:disable */
/* eslint-disable */
/**
 * Housecall v1 API
 * Housecall version 1 public API
 *
 * The version of the OpenAPI document: 1.0
 * Contact: apideveloper@housecallpro.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface Address
 */
export interface Address {
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'type'?: AddressTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'street'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'street_line_2'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'city'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'state'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'zip'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'country'?: string | null;
}

export const AddressTypeEnum = {
    Billing: 'billing',
    Service: 'service'
} as const;

export type AddressTypeEnum = typeof AddressTypeEnum[keyof typeof AddressTypeEnum];

/**
 * 
 * @export
 * @interface AddressCreate
 */
export interface AddressCreate {
    /**
     * 
     * @type {string}
     * @memberof AddressCreate
     */
    'street': string;
    /**
     * 
     * @type {string}
     * @memberof AddressCreate
     */
    'street_line_2'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AddressCreate
     */
    'city': string;
    /**
     * 
     * @type {string}
     * @memberof AddressCreate
     */
    'state': string;
    /**
     * 
     * @type {string}
     * @memberof AddressCreate
     */
    'zip': string;
    /**
     * 
     * @type {string}
     * @memberof AddressCreate
     */
    'country': string;
    /**
     * 
     * @type {AddressCreateLatitude}
     * @memberof AddressCreate
     */
    'latitude'?: AddressCreateLatitude;
    /**
     * 
     * @type {AddressCreateLatitude}
     * @memberof AddressCreate
     */
    'longitude'?: AddressCreateLatitude;
}
/**
 * @type AddressCreateLatitude
 * @export
 */
export type AddressCreateLatitude = number | string;

/**
 * 
 * @export
 * @interface Application
 */
export interface Application {
    /**
     * 
     * @type {string}
     * @memberof Application
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Application
     */
    'state': ApplicationStateEnum;
    /**
     * 
     * @type {string}
     * @memberof Application
     */
    'organization_id': string;
}

export const ApplicationStateEnum = {
    Enabled: 'enabled',
    Disabled: 'disabled',
    Pending: 'pending'
} as const;

export type ApplicationStateEnum = typeof ApplicationStateEnum[keyof typeof ApplicationStateEnum];

/**
 * 
 * @export
 * @interface Appointment
 */
export interface Appointment {
    /**
     * 
     * @type {string}
     * @memberof Appointment
     */
    'id'?: string;
    /**
     * Start time of job appointment in iso8601
     * @type {string}
     * @memberof Appointment
     */
    'start_time'?: string;
    /**
     * End time of job appointment in iso8601
     * @type {string}
     * @memberof Appointment
     */
    'end_time'?: string;
    /**
     * Integer value in minutes of arrival window
     * @type {number}
     * @memberof Appointment
     */
    'arrival_window_minutes'?: number;
    /**
     * List of pros ids to be assign in appointment
     * @type {Array<string>}
     * @memberof Appointment
     */
    'dispatched_employees_ids'?: Array<string>;
}
/**
 * 
 * @export
 * @interface Attachment
 */
export interface Attachment {
    /**
     * 
     * @type {string}
     * @memberof Attachment
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Attachment
     */
    'file_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Attachment
     */
    'url'?: string;
    /**
     * 
     * @type {string}
     * @memberof Attachment
     */
    'file_type'?: string;
}
/**
 * 
 * @export
 * @interface BookingWindows
 */
export interface BookingWindows {
    /**
     * 
     * @type {Array<BookingWindowsBookingWindowsInner>}
     * @memberof BookingWindows
     */
    'booking_windows'?: Array<BookingWindowsBookingWindowsInner>;
    /**
     * 
     * @type {number}
     * @memberof BookingWindows
     */
    'show_for_days'?: number;
    /**
     * 
     * @type {string}
     * @memberof BookingWindows
     */
    'start_date'?: string;
}
/**
 * 
 * @export
 * @interface BookingWindowsBookingWindowsInner
 */
export interface BookingWindowsBookingWindowsInner {
    /**
     * A timestamp of the start time of a booking window (UTC)
     * @type {string}
     * @memberof BookingWindowsBookingWindowsInner
     */
    'start_time'?: string;
    /**
     * A timestamp of the finish time of a booking window (UTC)
     * @type {string}
     * @memberof BookingWindowsBookingWindowsInner
     */
    'end_time'?: string;
    /**
     * The value representing if an organization is available during the booking window
     * @type {boolean}
     * @memberof BookingWindowsBookingWindowsInner
     */
    'available'?: boolean;
}
/**
 * 
 * @export
 * @interface Company
 */
export interface Company {
    /**
     * 
     * @type {string}
     * @memberof Company
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Company
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Company
     */
    'support_email'?: string;
    /**
     * 
     * @type {string}
     * @memberof Company
     */
    'phone_number'?: string;
    /**
     * 
     * @type {string}
     * @memberof Company
     */
    'logo_url'?: string;
    /**
     * 
     * @type {AddressCreate}
     * @memberof Company
     */
    'address'?: AddressCreate;
    /**
     * 
     * @type {string}
     * @memberof Company
     */
    'website'?: string;
    /**
     * 
     * @type {string}
     * @memberof Company
     */
    'default_arrival_window'?: string;
    /**
     * 
     * @type {string}
     * @memberof Company
     */
    'time_zone'?: string;
    /**
     * 
     * @type {Array<Company>}
     * @memberof Company
     */
    'locations'?: Array<Company>;
}
/**
 * 
 * @export
 * @interface CompleteScheduleAvailability
 */
export interface CompleteScheduleAvailability {
    /**
     * 
     * @type {number}
     * @memberof CompleteScheduleAvailability
     */
    'availability_buffer_in_days'?: number;
    /**
     * 
     * @type {CompleteScheduleAvailabilityDailyAvailabilities}
     * @memberof CompleteScheduleAvailability
     */
    'daily_availabilities'?: CompleteScheduleAvailabilityDailyAvailabilities;
}
/**
 * 
 * @export
 * @interface CompleteScheduleAvailabilityDailyAvailabilities
 */
export interface CompleteScheduleAvailabilityDailyAvailabilities {
    /**
     * 
     * @type {Array<CompleteScheduleAvailabilityDailyAvailabilitiesDataInner>}
     * @memberof CompleteScheduleAvailabilityDailyAvailabilities
     */
    'data'?: Array<CompleteScheduleAvailabilityDailyAvailabilitiesDataInner>;
}
/**
 * 
 * @export
 * @interface CompleteScheduleAvailabilityDailyAvailabilitiesDataInner
 */
export interface CompleteScheduleAvailabilityDailyAvailabilitiesDataInner {
    /**
     * 
     * @type {string}
     * @memberof CompleteScheduleAvailabilityDailyAvailabilitiesDataInner
     */
    'day_name'?: string;
    /**
     * 
     * @type {Array<CompleteScheduleAvailabilityDailyAvailabilitiesDataInnerScheduleWindowsInner>}
     * @memberof CompleteScheduleAvailabilityDailyAvailabilitiesDataInner
     */
    'schedule_windows'?: Array<CompleteScheduleAvailabilityDailyAvailabilitiesDataInnerScheduleWindowsInner>;
}
/**
 * 
 * @export
 * @interface CompleteScheduleAvailabilityDailyAvailabilitiesDataInnerScheduleWindowsInner
 */
export interface CompleteScheduleAvailabilityDailyAvailabilitiesDataInnerScheduleWindowsInner {
    /**
     * ISO-8601 formatted date string
     * @type {string}
     * @memberof CompleteScheduleAvailabilityDailyAvailabilitiesDataInnerScheduleWindowsInner
     */
    'start_time'?: string;
    /**
     * ISO-8601 formatted date string
     * @type {string}
     * @memberof CompleteScheduleAvailabilityDailyAvailabilitiesDataInnerScheduleWindowsInner
     */
    'end_time'?: string;
}
/**
 * 
 * @export
 * @interface CreateAppointment
 */
export interface CreateAppointment {
    /**
     * Start time of job appointment in iso8601
     * @type {string}
     * @memberof CreateAppointment
     */
    'start_time': string;
    /**
     * End time of job appointment in iso8601
     * @type {string}
     * @memberof CreateAppointment
     */
    'end_time': string;
    /**
     * Integer value in minutes of arrival window
     * @type {number}
     * @memberof CreateAppointment
     */
    'arrival_window_minutes'?: number;
    /**
     * List of pros ids to be assign in appointment
     * @type {Array<string>}
     * @memberof CreateAppointment
     */
    'dispatched_employees_ids': Array<string>;
}
/**
 * 
 * @export
 * @interface CreateEstimateOptionAttachment202Response
 */
export interface CreateEstimateOptionAttachment202Response {
    /**
     * 
     * @type {string}
     * @memberof CreateEstimateOptionAttachment202Response
     */
    'estimate_url'?: string;
}
/**
 * 
 * @export
 * @interface CreateMaterialCategoryRequest
 */
export interface CreateMaterialCategoryRequest {
    /**
     * UUID of the material category to create this new category under; if left blank, the category will be created at the root level
     * @type {string}
     * @memberof CreateMaterialCategoryRequest
     */
    'material_category_uuid'?: string;
    /**
     * name of the material category to be created
     * @type {string}
     * @memberof CreateMaterialCategoryRequest
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface CreateMaterialRequest
 */
export interface CreateMaterialRequest {
    /**
     * UUID of the material category to create this material under
     * @type {string}
     * @memberof CreateMaterialRequest
     */
    'material_category_uuid': string;
    /**
     * name of the material to be created
     * @type {string}
     * @memberof CreateMaterialRequest
     */
    'name': string;
    /**
     * description of the material to be created
     * @type {string}
     * @memberof CreateMaterialRequest
     */
    'description'?: string;
    /**
     * price of the material to be created in cents
     * @type {number}
     * @memberof CreateMaterialRequest
     */
    'price': number;
    /**
     * cost of the material to be created in cents
     * @type {number}
     * @memberof CreateMaterialRequest
     */
    'cost': number;
    /**
     * unit of measure of the material to be created (i.e. each)
     * @type {string}
     * @memberof CreateMaterialRequest
     */
    'unit_of_measure'?: string;
    /**
     * part number of the material to be created
     * @type {string}
     * @memberof CreateMaterialRequest
     */
    'part_number'?: string;
    /**
     * if the material should be taxable on invoice (default value is false)
     * @type {boolean}
     * @memberof CreateMaterialRequest
     */
    'taxable'?: boolean;
}
/**
 * 
 * @export
 * @interface Customer
 */
export interface Customer {
    /**
     * 
     * @type {string}
     * @memberof Customer
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Customer
     */
    'first_name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Customer
     */
    'last_name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Customer
     */
    'email'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Customer
     */
    'mobile_number'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Customer
     */
    'home_number'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Customer
     */
    'work_number'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Customer
     */
    'company'?: string | null;
    /**
     * Will the customer receive notifications
     * @type {boolean}
     * @memberof Customer
     */
    'notifications_enabled'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Customer
     */
    'lead_source'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Customer
     */
    'notes'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Customer
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof Customer
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof Customer
     */
    'company_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Customer
     */
    'company_id'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Customer
     */
    'tags'?: Array<string>;
    /**
     * 
     * @type {Array<Address>}
     * @memberof Customer
     */
    'addresses'?: Array<Address>;
    /**
     * Only present if expanded with attachments
     * @type {Array<Attachment>}
     * @memberof Customer
     */
    'attachments'?: Array<Attachment>;
}
/**
 * 
 * @export
 * @interface CustomerCreate
 */
export interface CustomerCreate {
    /**
     * 
     * @type {string}
     * @memberof CustomerCreate
     */
    'first_name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CustomerCreate
     */
    'last_name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CustomerCreate
     */
    'email'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CustomerCreate
     */
    'company'?: string | null;
    /**
     * Will the customer receive notifications
     * @type {boolean}
     * @memberof CustomerCreate
     */
    'notifications_enabled'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CustomerCreate
     */
    'mobile_number'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CustomerCreate
     */
    'home_number'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CustomerCreate
     */
    'work_number'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof CustomerCreate
     */
    'tags'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof CustomerCreate
     */
    'lead_source'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CustomerCreate
     */
    'notes'?: string;
    /**
     * 
     * @type {Array<CustomerCreateAddressesInner>}
     * @memberof CustomerCreate
     */
    'addresses'?: Array<CustomerCreateAddressesInner>;
}
/**
 * 
 * @export
 * @interface CustomerCreateAddressesInner
 */
export interface CustomerCreateAddressesInner {
    /**
     * 
     * @type {string}
     * @memberof CustomerCreateAddressesInner
     */
    'street'?: string;
    /**
     * 
     * @type {string}
     * @memberof CustomerCreateAddressesInner
     */
    'street_line_2'?: string;
    /**
     * 
     * @type {string}
     * @memberof CustomerCreateAddressesInner
     */
    'city'?: string;
    /**
     * 
     * @type {string}
     * @memberof CustomerCreateAddressesInner
     */
    'state'?: string;
    /**
     * 
     * @type {string}
     * @memberof CustomerCreateAddressesInner
     */
    'zip'?: string;
    /**
     * 
     * @type {string}
     * @memberof CustomerCreateAddressesInner
     */
    'country'?: string;
}
/**
 * 
 * @export
 * @interface CustomerUpdate
 */
export interface CustomerUpdate {
    /**
     * 
     * @type {string}
     * @memberof CustomerUpdate
     */
    'first_name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CustomerUpdate
     */
    'last_name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CustomerUpdate
     */
    'email'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CustomerUpdate
     */
    'company'?: string | null;
    /**
     * Will the customer receive notifications
     * @type {boolean}
     * @memberof CustomerUpdate
     */
    'notifications_enabled'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CustomerUpdate
     */
    'mobile_number'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CustomerUpdate
     */
    'home_number'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CustomerUpdate
     */
    'work_number'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof CustomerUpdate
     */
    'tags'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof CustomerUpdate
     */
    'lead_source'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CustomerUpdate
     */
    'note'?: string;
}
/**
 * 
 * @export
 * @interface DeleteJobSchedule200Response
 */
export interface DeleteJobSchedule200Response {
    /**
     * 
     * @type {string}
     * @memberof DeleteJobSchedule200Response
     */
    'object': string;
    /**
     * 
     * @type {boolean}
     * @memberof DeleteJobSchedule200Response
     */
    'deleted': boolean;
}
/**
 * 
 * @export
 * @interface DispatchedEmployee
 */
export interface DispatchedEmployee {
    /**
     * ID of the employee assigned to the job
     * @type {string}
     * @memberof DispatchedEmployee
     */
    'employee_id'?: string;
}
/**
 * 
 * @export
 * @interface Employee
 */
export interface Employee {
    /**
     * 
     * @type {string}
     * @memberof Employee
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Employee
     */
    'first_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Employee
     */
    'last_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Employee
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof Employee
     */
    'mobile_number'?: string;
    /**
     * 
     * @type {string}
     * @memberof Employee
     */
    'color_hex'?: string;
    /**
     * 
     * @type {string}
     * @memberof Employee
     */
    'avatar_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof Employee
     */
    'role'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Employee
     */
    'tags'?: Array<string>;
    /**
     * 
     * @type {EmployeeAllOfPermissions}
     * @memberof Employee
     */
    'permissions'?: EmployeeAllOfPermissions;
    /**
     * 
     * @type {string}
     * @memberof Employee
     */
    'company_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Employee
     */
    'company_id'?: string;
}
/**
 * 
 * @export
 * @interface EmployeeAllOfPermissions
 */
export interface EmployeeAllOfPermissions {
    /**
     * 
     * @type {boolean}
     * @memberof EmployeeAllOfPermissions
     */
    'can_add_and_edit_job'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof EmployeeAllOfPermissions
     */
    'can_be_booked_online'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof EmployeeAllOfPermissions
     */
    'can_call_and_text_with_customers'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof EmployeeAllOfPermissions
     */
    'can_chat_with_customers'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof EmployeeAllOfPermissions
     */
    'can_delete_and_cancel_job'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof EmployeeAllOfPermissions
     */
    'can_edit_message_on_invoice'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof EmployeeAllOfPermissions
     */
    'can_see_street_view_data'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof EmployeeAllOfPermissions
     */
    'can_share_job'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof EmployeeAllOfPermissions
     */
    'can_take_payment_see_prices'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof EmployeeAllOfPermissions
     */
    'can_see_customers'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof EmployeeAllOfPermissions
     */
    'can_see_full_schedule'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof EmployeeAllOfPermissions
     */
    'can_see_future_jobs'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof EmployeeAllOfPermissions
     */
    'can_see_marketing_campaigns'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof EmployeeAllOfPermissions
     */
    'can_see_reporting'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof EmployeeAllOfPermissions
     */
    'can_edit_settings'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof EmployeeAllOfPermissions
     */
    'is_point_of_contact'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof EmployeeAllOfPermissions
     */
    'is_admin'?: boolean;
}
/**
 * 
 * @export
 * @interface Estimate
 */
export interface Estimate {
    /**
     * 
     * @type {string}
     * @memberof Estimate
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Estimate
     */
    'estimate_number'?: string;
    /**
     * 
     * @type {string}
     * @memberof Estimate
     */
    'work_status'?: string;
    /**
     * 
     * @type {string}
     * @memberof Estimate
     */
    'lead_source'?: string | null;
    /**
     * 
     * @type {EstimateCustomer}
     * @memberof Estimate
     */
    'customer'?: EstimateCustomer;
    /**
     * 
     * @type {Address}
     * @memberof Estimate
     */
    'address'?: Address | null;
    /**
     * 
     * @type {string}
     * @memberof Estimate
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof Estimate
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof Estimate
     */
    'company_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Estimate
     */
    'company_id'?: string;
    /**
     * 
     * @type {WorkTimestamps}
     * @memberof Estimate
     */
    'work_timestamps'?: WorkTimestamps;
    /**
     * 
     * @type {Schedule}
     * @memberof Estimate
     */
    'schedule'?: Schedule;
    /**
     * 
     * @type {Array<Employee>}
     * @memberof Estimate
     */
    'assigned_employees'?: Array<Employee>;
    /**
     * 
     * @type {JobCreateJobFields}
     * @memberof Estimate
     */
    'estimate_fields'?: JobCreateJobFields;
    /**
     * 
     * @type {Array<EstimateOption>}
     * @memberof Estimate
     */
    'options'?: Array<EstimateOption>;
}
/**
 * 
 * @export
 * @interface EstimateCreate
 */
export interface EstimateCreate {
    /**
     * Estimate number unique across all of a company\'s estimates in Housecall Pro. If left blank, one will be automatically generated.
     * @type {number}
     * @memberof EstimateCreate
     */
    'estimate_number'?: number;
    /**
     * 
     * @type {string}
     * @memberof EstimateCreate
     */
    'note'?: string;
    /**
     * 
     * @type {string}
     * @memberof EstimateCreate
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof EstimateCreate
     */
    'customer_id'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof EstimateCreate
     */
    'assigned_employee_ids'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof EstimateCreate
     */
    'address_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof EstimateCreate
     */
    'lead_source'?: string;
    /**
     * 
     * @type {EstimateCreateAddress}
     * @memberof EstimateCreate
     */
    'address'?: EstimateCreateAddress;
    /**
     * 
     * @type {Array<EstimateCreateOptionsInner>}
     * @memberof EstimateCreate
     */
    'options'?: Array<EstimateCreateOptionsInner>;
    /**
     * 
     * @type {EstimateCreateTax}
     * @memberof EstimateCreate
     */
    'tax'?: EstimateCreateTax;
    /**
     * 
     * @type {EstimateCreateSchedule}
     * @memberof EstimateCreate
     */
    'schedule'?: EstimateCreateSchedule;
    /**
     * 
     * @type {JobCreateJobFields}
     * @memberof EstimateCreate
     */
    'estimate_fields'?: JobCreateJobFields;
}
/**
 * 
 * @export
 * @interface EstimateCreateAddress
 */
export interface EstimateCreateAddress {
    /**
     * 
     * @type {string}
     * @memberof EstimateCreateAddress
     */
    'street'?: string;
    /**
     * 
     * @type {string}
     * @memberof EstimateCreateAddress
     */
    'street_line_2'?: string;
    /**
     * 
     * @type {string}
     * @memberof EstimateCreateAddress
     */
    'city'?: string;
    /**
     * 
     * @type {string}
     * @memberof EstimateCreateAddress
     */
    'state'?: string;
    /**
     * 
     * @type {string}
     * @memberof EstimateCreateAddress
     */
    'zip'?: string;
}
/**
 * 
 * @export
 * @interface EstimateCreateOptionsInner
 */
export interface EstimateCreateOptionsInner {
    /**
     * 
     * @type {string}
     * @memberof EstimateCreateOptionsInner
     */
    'name'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof EstimateCreateOptionsInner
     */
    'tags'?: Array<string>;
    /**
     * 
     * @type {Array<LineItemCreate>}
     * @memberof EstimateCreateOptionsInner
     */
    'line_items'?: Array<LineItemCreate>;
}
/**
 * 
 * @export
 * @interface EstimateCreateSchedule
 */
export interface EstimateCreateSchedule {
    /**
     * 
     * @type {string}
     * @memberof EstimateCreateSchedule
     */
    'start_time'?: string;
    /**
     * 
     * @type {string}
     * @memberof EstimateCreateSchedule
     */
    'end_time'?: string;
    /**
     * 
     * @type {number}
     * @memberof EstimateCreateSchedule
     */
    'arrival_window_in_minutes'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof EstimateCreateSchedule
     */
    'notify_customer'?: boolean;
}
/**
 * 
 * @export
 * @interface EstimateCreateTax
 */
export interface EstimateCreateTax {
    /**
     * 
     * @type {boolean}
     * @memberof EstimateCreateTax
     */
    'taxable'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof EstimateCreateTax
     */
    'tax_rate'?: number;
    /**
     * 
     * @type {string}
     * @memberof EstimateCreateTax
     */
    'tax_name'?: string;
}
/**
 * 
 * @export
 * @interface EstimateCustomer
 */
export interface EstimateCustomer {
    /**
     * 
     * @type {string}
     * @memberof EstimateCustomer
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof EstimateCustomer
     */
    'first_name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof EstimateCustomer
     */
    'last_name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof EstimateCustomer
     */
    'email'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof EstimateCustomer
     */
    'mobile_number'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof EstimateCustomer
     */
    'home_number'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof EstimateCustomer
     */
    'work_number'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof EstimateCustomer
     */
    'company'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof EstimateCustomer
     */
    'notifications_enabled'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof EstimateCustomer
     */
    'lead_source'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof EstimateCustomer
     */
    'notes'?: string;
    /**
     * 
     * @type {string}
     * @memberof EstimateCustomer
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof EstimateCustomer
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof EstimateCustomer
     */
    'company_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof EstimateCustomer
     */
    'company_id'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof EstimateCustomer
     */
    'tags'?: Array<string>;
}
/**
 * 
 * @export
 * @interface EstimateOption
 */
export interface EstimateOption {
    /**
     * 
     * @type {string}
     * @memberof EstimateOption
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof EstimateOption
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof EstimateOption
     */
    'option_number'?: string;
    /**
     * 
     * @type {number}
     * @memberof EstimateOption
     */
    'total_amount'?: number;
    /**
     * 
     * @type {string}
     * @memberof EstimateOption
     */
    'approval_status'?: string;
    /**
     * 
     * @type {string}
     * @memberof EstimateOption
     */
    'message_from_pro'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof EstimateOption
     */
    'tags'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof EstimateOption
     */
    'status'?: string;
    /**
     * 
     * @type {Array<Note>}
     * @memberof EstimateOption
     */
    'notes'?: Array<Note>;
    /**
     * 
     * @type {string}
     * @memberof EstimateOption
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof EstimateOption
     */
    'updated_at'?: string;
    /**
     * Only present if expanded with attachments
     * @type {Array<Attachment>}
     * @memberof EstimateOption
     */
    'attachments'?: Array<Attachment>;
}
/**
 * 
 * @export
 * @interface Event
 */
export interface Event {
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    'note'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof Event
     */
    'tags'?: Array<string>;
    /**
     * iCal format
     * @type {string}
     * @memberof Event
     */
    'recurrence_rule'?: string | null;
    /**
     * 
     * @type {EstimateCreateAddress}
     * @memberof Event
     */
    'address'?: EstimateCreateAddress;
    /**
     * 
     * @type {Array<Employee>}
     * @memberof Event
     */
    'assigned_employees'?: Array<Employee>;
    /**
     * 
     * @type {EventSchedule}
     * @memberof Event
     */
    'schedule'?: EventSchedule;
    /**
     * 
     * @type {boolean}
     * @memberof Event
     */
    'all_day'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    'company_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    'company_id'?: string;
}
/**
 * 
 * @export
 * @interface EventSchedule
 */
export interface EventSchedule {
    /**
     * 
     * @type {string}
     * @memberof EventSchedule
     */
    'start_time'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventSchedule
     */
    'end_time'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventSchedule
     */
    'time_zone'?: string;
}
/**
 * 
 * @export
 * @interface GetCustomerCustomerIdAddressesRequest
 */
export interface GetCustomerCustomerIdAddressesRequest {
    /**
     * 
     * @type {number}
     * @memberof GetCustomerCustomerIdAddressesRequest
     */
    'page': number;
    /**
     * 
     * @type {number}
     * @memberof GetCustomerCustomerIdAddressesRequest
     */
    'page_size': number;
    /**
     * 
     * @type {number}
     * @memberof GetCustomerCustomerIdAddressesRequest
     */
    'total_pages': number;
    /**
     * 
     * @type {number}
     * @memberof GetCustomerCustomerIdAddressesRequest
     */
    'total_items': number;
    /**
     * 
     * @type {Array<Address>}
     * @memberof GetCustomerCustomerIdAddressesRequest
     */
    'addresses'?: Array<Address>;
}
/**
 * 
 * @export
 * @interface GetEmployees200Response
 */
export interface GetEmployees200Response {
    /**
     * 
     * @type {number}
     * @memberof GetEmployees200Response
     */
    'page'?: number;
    /**
     * 
     * @type {number}
     * @memberof GetEmployees200Response
     */
    'page_size'?: number;
    /**
     * 
     * @type {number}
     * @memberof GetEmployees200Response
     */
    'total_pages'?: number;
    /**
     * 
     * @type {number}
     * @memberof GetEmployees200Response
     */
    'total_items'?: number;
    /**
     * 
     * @type {Array<Employee>}
     * @memberof GetEmployees200Response
     */
    'employees'?: Array<Employee>;
}
/**
 * 
 * @export
 * @interface GetEstiamtes200Response
 */
export interface GetEstiamtes200Response {
    /**
     * 
     * @type {number}
     * @memberof GetEstiamtes200Response
     */
    'page': number;
    /**
     * 
     * @type {number}
     * @memberof GetEstiamtes200Response
     */
    'page_size': number;
    /**
     * 
     * @type {number}
     * @memberof GetEstiamtes200Response
     */
    'total_pages': number;
    /**
     * 
     * @type {number}
     * @memberof GetEstiamtes200Response
     */
    'total_items': number;
    /**
     * 
     * @type {Array<Estimate>}
     * @memberof GetEstiamtes200Response
     */
    'estimates'?: Array<Estimate>;
}
/**
 * 
 * @export
 * @interface GetEvents200Response
 */
export interface GetEvents200Response {
    /**
     * 
     * @type {number}
     * @memberof GetEvents200Response
     */
    'page'?: number;
    /**
     * 
     * @type {number}
     * @memberof GetEvents200Response
     */
    'page_size'?: number;
    /**
     * 
     * @type {number}
     * @memberof GetEvents200Response
     */
    'total_pages'?: number;
    /**
     * 
     * @type {number}
     * @memberof GetEvents200Response
     */
    'total_items'?: number;
    /**
     * 
     * @type {Array<Event>}
     * @memberof GetEvents200Response
     */
    'events'?: Array<Event>;
}
/**
 * 
 * @export
 * @interface GetInvoices200Response
 */
export interface GetInvoices200Response {
    /**
     * 
     * @type {number}
     * @memberof GetInvoices200Response
     */
    'page': number;
    /**
     * 
     * @type {number}
     * @memberof GetInvoices200Response
     */
    'page_size': number;
    /**
     * 
     * @type {number}
     * @memberof GetInvoices200Response
     */
    'total_pages': number;
    /**
     * 
     * @type {number}
     * @memberof GetInvoices200Response
     */
    'total_items': number;
    /**
     * 
     * @type {Array<GetInvoices200ResponseAllOfInvoicesInner>}
     * @memberof GetInvoices200Response
     */
    'invoices'?: Array<GetInvoices200ResponseAllOfInvoicesInner>;
}
/**
 * 
 * @export
 * @interface GetInvoices200ResponseAllOfInvoicesInner
 */
export interface GetInvoices200ResponseAllOfInvoicesInner {
    /**
     * 
     * @type {string}
     * @memberof GetInvoices200ResponseAllOfInvoicesInner
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetInvoices200ResponseAllOfInvoicesInner
     */
    'status'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetInvoices200ResponseAllOfInvoicesInner
     */
    'invoice_number'?: string;
    /**
     * 
     * @type {number}
     * @memberof GetInvoices200ResponseAllOfInvoicesInner
     */
    'amount'?: number;
    /**
     * 
     * @type {number}
     * @memberof GetInvoices200ResponseAllOfInvoicesInner
     */
    'due_amount'?: number;
    /**
     * 
     * @type {string}
     * @memberof GetInvoices200ResponseAllOfInvoicesInner
     */
    'due_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetInvoices200ResponseAllOfInvoicesInner
     */
    'display_due_concept'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetInvoices200ResponseAllOfInvoicesInner
     */
    'due_concept'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetInvoices200ResponseAllOfInvoicesInner
     */
    'paid_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetInvoices200ResponseAllOfInvoicesInner
     */
    'sent_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetInvoices200ResponseAllOfInvoicesInner
     */
    'service_date'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetInvoices200ResponseAllOfInvoicesInner
     */
    'invoice_date'?: string;
    /**
     * 
     * @type {Array<InvoiceItem>}
     * @memberof GetInvoices200ResponseAllOfInvoicesInner
     */
    'items'?: Array<InvoiceItem>;
    /**
     * 
     * @type {Array<InvoiceTax>}
     * @memberof GetInvoices200ResponseAllOfInvoicesInner
     */
    'taxes'?: Array<InvoiceTax>;
    /**
     * 
     * @type {Array<InvoiceDiscount>}
     * @memberof GetInvoices200ResponseAllOfInvoicesInner
     */
    'discounts'?: Array<InvoiceDiscount>;
    /**
     * 
     * @type {Array<InvoicePayment>}
     * @memberof GetInvoices200ResponseAllOfInvoicesInner
     */
    'payments'?: Array<InvoicePayment>;
    /**
     * 
     * @type {string}
     * @memberof GetInvoices200ResponseAllOfInvoicesInner
     */
    'job_id'?: string;
}
/**
 * 
 * @export
 * @interface GetJobFieldsJobTypes200Response
 */
export interface GetJobFieldsJobTypes200Response {
    /**
     * 
     * @type {number}
     * @memberof GetJobFieldsJobTypes200Response
     */
    'page': number;
    /**
     * 
     * @type {number}
     * @memberof GetJobFieldsJobTypes200Response
     */
    'page_size': number;
    /**
     * 
     * @type {number}
     * @memberof GetJobFieldsJobTypes200Response
     */
    'total_pages': number;
    /**
     * 
     * @type {number}
     * @memberof GetJobFieldsJobTypes200Response
     */
    'total_items': number;
    /**
     * 
     * @type {Array<JobType>}
     * @memberof GetJobFieldsJobTypes200Response
     */
    'job_types'?: Array<JobType>;
}
/**
 * 
 * @export
 * @interface GetJobs200Response
 */
export interface GetJobs200Response {
    /**
     * 
     * @type {number}
     * @memberof GetJobs200Response
     */
    'page': number;
    /**
     * 
     * @type {number}
     * @memberof GetJobs200Response
     */
    'page_size': number;
    /**
     * 
     * @type {number}
     * @memberof GetJobs200Response
     */
    'total_pages': number;
    /**
     * 
     * @type {number}
     * @memberof GetJobs200Response
     */
    'total_items': number;
    /**
     * 
     * @type {Array<Job>}
     * @memberof GetJobs200Response
     */
    'jobs'?: Array<Job>;
}
/**
 * 
 * @export
 * @interface GetJobsId404Response
 */
export interface GetJobsId404Response {
    /**
     * 
     * @type {string}
     * @memberof GetJobsId404Response
     */
    ''?: string;
}
/**
 * 
 * @export
 * @interface GetJobsJobIdAppointments200Response
 */
export interface GetJobsJobIdAppointments200Response {
    /**
     * 
     * @type {Array<Appointment>}
     * @memberof GetJobsJobIdAppointments200Response
     */
    'appointments'?: Array<Appointment>;
}
/**
 * 
 * @export
 * @interface GetJobsJobIdInvoices200Response
 */
export interface GetJobsJobIdInvoices200Response {
    /**
     * 
     * @type {Array<JobInvoice>}
     * @memberof GetJobsJobIdInvoices200Response
     */
    'invoices'?: Array<JobInvoice>;
}
/**
 * 
 * @export
 * @interface GetJobsJobIdLineItems200Response
 */
export interface GetJobsJobIdLineItems200Response {
    /**
     * 
     * @type {string}
     * @memberof GetJobsJobIdLineItems200Response
     */
    'url'?: string;
    /**
     * 
     * @type {Array<LineItem>}
     * @memberof GetJobsJobIdLineItems200Response
     */
    'data'?: Array<LineItem>;
}
/**
 * 
 * @export
 * @interface GetLeadSources200Response
 */
export interface GetLeadSources200Response {
    /**
     * 
     * @type {number}
     * @memberof GetLeadSources200Response
     */
    'page': number;
    /**
     * 
     * @type {number}
     * @memberof GetLeadSources200Response
     */
    'page_size': number;
    /**
     * 
     * @type {number}
     * @memberof GetLeadSources200Response
     */
    'total_pages': number;
    /**
     * 
     * @type {number}
     * @memberof GetLeadSources200Response
     */
    'total_items': number;
    /**
     * 
     * @type {Array<LeadSource>}
     * @memberof GetLeadSources200Response
     */
    'lead_sources'?: Array<LeadSource>;
}
/**
 * 
 * @export
 * @interface GetLeads200Response
 */
export interface GetLeads200Response {
    /**
     * 
     * @type {number}
     * @memberof GetLeads200Response
     */
    'page': number;
    /**
     * 
     * @type {number}
     * @memberof GetLeads200Response
     */
    'page_size': number;
    /**
     * 
     * @type {number}
     * @memberof GetLeads200Response
     */
    'total_pages': number;
    /**
     * 
     * @type {number}
     * @memberof GetLeads200Response
     */
    'total_items': number;
    /**
     * 
     * @type {Array<Lead>}
     * @memberof GetLeads200Response
     */
    'leads'?: Array<Lead>;
}
/**
 * 
 * @export
 * @interface GetTags200Response
 */
export interface GetTags200Response {
    /**
     * 
     * @type {number}
     * @memberof GetTags200Response
     */
    'page': number;
    /**
     * 
     * @type {number}
     * @memberof GetTags200Response
     */
    'page_size': number;
    /**
     * 
     * @type {number}
     * @memberof GetTags200Response
     */
    'total_pages': number;
    /**
     * 
     * @type {number}
     * @memberof GetTags200Response
     */
    'total_items': number;
    /**
     * 
     * @type {Array<Tag>}
     * @memberof GetTags200Response
     */
    'tags'?: Array<Tag>;
}
/**
 * 
 * @export
 * @interface GetV1Customers200Response
 */
export interface GetV1Customers200Response {
    /**
     * 
     * @type {number}
     * @memberof GetV1Customers200Response
     */
    'page': number;
    /**
     * 
     * @type {number}
     * @memberof GetV1Customers200Response
     */
    'page_size': number;
    /**
     * 
     * @type {number}
     * @memberof GetV1Customers200Response
     */
    'total_pages': number;
    /**
     * 
     * @type {number}
     * @memberof GetV1Customers200Response
     */
    'total_items': number;
    /**
     * 
     * @type {Array<Customer>}
     * @memberof GetV1Customers200Response
     */
    'customers'?: Array<Customer>;
}
/**
 * 
 * @export
 * @interface IndexMaterialCategories200Response
 */
export interface IndexMaterialCategories200Response {
    /**
     * list
     * @type {number}
     * @memberof IndexMaterialCategories200Response
     */
    'object'?: number;
    /**
     * page number of the paginated list
     * @type {number}
     * @memberof IndexMaterialCategories200Response
     */
    'page'?: number;
    /**
     * number of pages of the whole document
     * @type {number}
     * @memberof IndexMaterialCategories200Response
     */
    'page_size'?: number;
    /**
     * total records count
     * @type {number}
     * @memberof IndexMaterialCategories200Response
     */
    'total_count'?: number;
    /**
     * 
     * @type {MaterialCategory}
     * @memberof IndexMaterialCategories200Response
     */
    'data'?: MaterialCategory;
}
/**
 * 
 * @export
 * @interface IndexMaterials200Response
 */
export interface IndexMaterials200Response {
    /**
     * list
     * @type {string}
     * @memberof IndexMaterials200Response
     */
    'object'?: string;
    /**
     * page number of the paginated list
     * @type {number}
     * @memberof IndexMaterials200Response
     */
    'page'?: number;
    /**
     * number of items per page
     * @type {number}
     * @memberof IndexMaterials200Response
     */
    'page_size'?: number;
    /**
     * number of pages of the whole document
     * @type {number}
     * @memberof IndexMaterials200Response
     */
    'total_pages_count'?: number;
    /**
     * total records count
     * @type {number}
     * @memberof IndexMaterials200Response
     */
    'total_count'?: number;
    /**
     * 
     * @type {Material}
     * @memberof IndexMaterials200Response
     */
    'data'?: Material;
}
/**
 * 
 * @export
 * @interface InvoiceDiscount
 */
export interface InvoiceDiscount {
    /**
     * 
     * @type {number}
     * @memberof InvoiceDiscount
     */
    'amount'?: number;
    /**
     * 
     * @type {string}
     * @memberof InvoiceDiscount
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceDiscount
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface InvoiceItem
 */
export interface InvoiceItem {
    /**
     * 
     * @type {string}
     * @memberof InvoiceItem
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof InvoiceItem
     */
    'unit_cost'?: number;
    /**
     * 
     * @type {number}
     * @memberof InvoiceItem
     */
    'unit_price'?: number;
    /**
     * 
     * @type {number}
     * @memberof InvoiceItem
     */
    'qty_in_hundredths'?: number;
    /**
     * 
     * @type {number}
     * @memberof InvoiceItem
     */
    'amount'?: number;
    /**
     * 
     * @type {string}
     * @memberof InvoiceItem
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceItem
     */
    'type'?: string;
}
/**
 * 
 * @export
 * @interface InvoicePayment
 */
export interface InvoicePayment {
    /**
     * 
     * @type {string}
     * @memberof InvoicePayment
     */
    'status'?: string;
    /**
     * 
     * @type {string}
     * @memberof InvoicePayment
     */
    'payment_method'?: string;
    /**
     * 
     * @type {number}
     * @memberof InvoicePayment
     */
    'amount'?: number;
    /**
     * 
     * @type {string}
     * @memberof InvoicePayment
     */
    'note'?: string;
    /**
     * 
     * @type {string}
     * @memberof InvoicePayment
     */
    'paid_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof InvoicePayment
     */
    'category'?: string;
}
/**
 * 
 * @export
 * @interface InvoiceTax
 */
export interface InvoiceTax {
    /**
     * 
     * @type {number}
     * @memberof InvoiceTax
     */
    'rate'?: number;
    /**
     * 
     * @type {number}
     * @memberof InvoiceTax
     */
    'amount'?: number;
    /**
     * 
     * @type {string}
     * @memberof InvoiceTax
     */
    'name'?: string;
}
/**
 * A single job segment.
 * @export
 * @interface Job
 */
export interface Job {
    /**
     * 
     * @type {string}
     * @memberof Job
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Job
     */
    'invoice_number'?: string;
    /**
     * 
     * @type {string}
     * @memberof Job
     */
    'description'?: string;
    /**
     * 
     * @type {JobCustomer}
     * @memberof Job
     */
    'customer'?: JobCustomer;
    /**
     * 
     * @type {Address}
     * @memberof Job
     */
    'address'?: Address | null;
    /**
     * 
     * @type {Array<Note>}
     * @memberof Job
     */
    'notes'?: Array<Note>;
    /**
     * 
     * @type {string}
     * @memberof Job
     */
    'work_status'?: JobWorkStatusEnum;
    /**
     * 
     * @type {WorkTimestamps}
     * @memberof Job
     */
    'work_timestamps'?: WorkTimestamps;
    /**
     * 
     * @type {Schedule}
     * @memberof Job
     */
    'schedule'?: Schedule;
    /**
     * 
     * @type {number}
     * @memberof Job
     */
    'total_amount'?: number;
    /**
     * 
     * @type {number}
     * @memberof Job
     */
    'outstanding_balance'?: number;
    /**
     * 
     * @type {Array<Employee>}
     * @memberof Job
     */
    'assigned_employees'?: Array<Employee>;
    /**
     * 
     * @type {Array<string>}
     * @memberof Job
     */
    'tags'?: Array<string>;
    /**
     * null unless job has been copied from an estimate
     * @type {string}
     * @memberof Job
     */
    'original_estimate_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Job
     */
    'lead_source'?: string | null;
    /**
     * 
     * @type {JobJobFields}
     * @memberof Job
     */
    'job_fields'?: JobJobFields;
    /**
     * Only present if expanded with attachments
     * @type {Array<Attachment>}
     * @memberof Job
     */
    'attachments'?: Array<Attachment>;
    /**
     * 
     * @type {string}
     * @memberof Job
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof Job
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof Job
     */
    'company_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Job
     */
    'company_id'?: string;
}

export const JobWorkStatusEnum = {
    Unscheduled: 'unscheduled',
    Scheduled: 'scheduled',
    InProgress: 'in_progress',
    CompleteRated: 'complete_rated',
    CompleteUnrated: 'complete_unrated',
    UserCanceled: 'user_canceled',
    ProCanceled: 'pro_canceled'
} as const;

export type JobWorkStatusEnum = typeof JobWorkStatusEnum[keyof typeof JobWorkStatusEnum];

/**
 * Object used when creating a job.
 * @export
 * @interface JobCreate
 */
export interface JobCreate {
    /**
     * Invoice number must be unique across all of a company\'s jobs in Housecall Pro. If left blank, one will be automatically generated.
     * @type {number}
     * @memberof JobCreate
     */
    'invoice_number'?: number;
    /**
     * 
     * @type {string}
     * @memberof JobCreate
     */
    'customer_id': string;
    /**
     * 
     * @type {string}
     * @memberof JobCreate
     */
    'address_id': string;
    /**
     * 
     * @type {JobCreateSchedule}
     * @memberof JobCreate
     */
    'schedule'?: JobCreateSchedule;
    /**
     * 
     * @type {Array<string>}
     * @memberof JobCreate
     */
    'assigned_employee_ids'?: Array<string>;
    /**
     * 
     * @type {Array<LineItemCreate>}
     * @memberof JobCreate
     */
    'line_items'?: Array<LineItemCreate>;
    /**
     * 
     * @type {Array<string>}
     * @memberof JobCreate
     */
    'tags'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof JobCreate
     */
    'lead_source'?: string;
    /**
     * 
     * @type {string}
     * @memberof JobCreate
     */
    'notes'?: string;
    /**
     * 
     * @type {JobCreateJobFields}
     * @memberof JobCreate
     */
    'job_fields'?: JobCreateJobFields;
}
/**
 * 
 * @export
 * @interface JobCreateJobFields
 */
export interface JobCreateJobFields {
    /**
     * 
     * @type {string}
     * @memberof JobCreateJobFields
     */
    'job_type_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof JobCreateJobFields
     */
    'business_unit_id'?: string;
}
/**
 * 
 * @export
 * @interface JobCreateSchedule
 */
export interface JobCreateSchedule {
    /**
     * ISO-8601 formatted date string YYYY-MM-DD(2023-03-23)
     * @type {string}
     * @memberof JobCreateSchedule
     */
    'scheduled_start'?: string;
    /**
     * ISO-8601 formatted date string YYYY-MM-DD(2023-03-23)
     * @type {string}
     * @memberof JobCreateSchedule
     */
    'scheduled_end'?: string;
    /**
     * In minutes
     * @type {number}
     * @memberof JobCreateSchedule
     */
    'arrival_window'?: number;
}
/**
 * 
 * @export
 * @interface JobCustomer
 */
export interface JobCustomer {
    /**
     * 
     * @type {string}
     * @memberof JobCustomer
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof JobCustomer
     */
    'first_name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof JobCustomer
     */
    'last_name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof JobCustomer
     */
    'email'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof JobCustomer
     */
    'mobile_number'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof JobCustomer
     */
    'home_number'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof JobCustomer
     */
    'work_number'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof JobCustomer
     */
    'company'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof JobCustomer
     */
    'notifications_enabled'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof JobCustomer
     */
    'lead_source'?: string | null;
    /**
     * 
     * @type {Array<Note>}
     * @memberof JobCustomer
     */
    'notes'?: Array<Note>;
    /**
     * 
     * @type {string}
     * @memberof JobCustomer
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof JobCustomer
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof JobCustomer
     */
    'company_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof JobCustomer
     */
    'company_id'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof JobCustomer
     */
    'tags'?: Array<string>;
}
/**
 * 
 * @export
 * @interface JobInvoice
 */
export interface JobInvoice {
    /**
     * 
     * @type {string}
     * @memberof JobInvoice
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof JobInvoice
     */
    'status'?: string;
    /**
     * 
     * @type {string}
     * @memberof JobInvoice
     */
    'invoice_number'?: string;
    /**
     * 
     * @type {number}
     * @memberof JobInvoice
     */
    'amount'?: number;
    /**
     * 
     * @type {number}
     * @memberof JobInvoice
     */
    'due_amount'?: number;
    /**
     * 
     * @type {string}
     * @memberof JobInvoice
     */
    'due_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof JobInvoice
     */
    'display_due_concept'?: string;
    /**
     * 
     * @type {string}
     * @memberof JobInvoice
     */
    'due_concept'?: string;
    /**
     * 
     * @type {string}
     * @memberof JobInvoice
     */
    'paid_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof JobInvoice
     */
    'sent_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof JobInvoice
     */
    'service_date'?: string;
    /**
     * 
     * @type {string}
     * @memberof JobInvoice
     */
    'invoice_date'?: string;
    /**
     * 
     * @type {Array<InvoiceItem>}
     * @memberof JobInvoice
     */
    'items'?: Array<InvoiceItem>;
    /**
     * 
     * @type {Array<InvoiceTax>}
     * @memberof JobInvoice
     */
    'taxes'?: Array<InvoiceTax>;
    /**
     * 
     * @type {Array<InvoiceDiscount>}
     * @memberof JobInvoice
     */
    'discounts'?: Array<InvoiceDiscount>;
    /**
     * 
     * @type {Array<InvoicePayment>}
     * @memberof JobInvoice
     */
    'payments'?: Array<InvoicePayment>;
}
/**
 * 
 * @export
 * @interface JobJobFields
 */
export interface JobJobFields {
    /**
     * 
     * @type {JobType}
     * @memberof JobJobFields
     */
    'job_type'?: JobType;
    /**
     * 
     * @type {JobType}
     * @memberof JobJobFields
     */
    'business_unit'?: JobType;
}
/**
 * 
 * @export
 * @interface JobLink
 */
export interface JobLink {
    /**
     * 
     * @type {string}
     * @memberof JobLink
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof JobLink
     */
    'url': string;
    /**
     * 
     * @type {string}
     * @memberof JobLink
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface JobLinkCreate
 */
export interface JobLinkCreate {
    /**
     * 
     * @type {string}
     * @memberof JobLinkCreate
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof JobLinkCreate
     */
    'url': string;
}
/**
 * 
 * @export
 * @interface JobType
 */
export interface JobType {
    /**
     * 
     * @type {string}
     * @memberof JobType
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof JobType
     */
    'name'?: string;
}
/**
 * Object return on leads
 * @export
 * @interface Lead
 */
export interface Lead {
    /**
     * 
     * @type {string}
     * @memberof Lead
     */
    'id'?: string;
    /**
     * 
     * @type {number}
     * @memberof Lead
     */
    'number'?: number;
    /**
     * 
     * @type {LeadCustomer}
     * @memberof Lead
     */
    'customer'?: LeadCustomer;
    /**
     * 
     * @type {LeadCreateAddress}
     * @memberof Lead
     */
    'address'?: LeadCreateAddress;
    /**
     * 
     * @type {string}
     * @memberof Lead
     */
    'lead_source'?: string;
    /**
     * 
     * @type {Array<LeadLineItemsInner>}
     * @memberof Lead
     */
    'line_items'?: Array<LeadLineItemsInner>;
    /**
     * 
     * @type {Array<string>}
     * @memberof Lead
     */
    'tags'?: Array<string>;
    /**
     * 
     * @type {Employee}
     * @memberof Lead
     */
    'assigned_employee'?: Employee;
    /**
     * 
     * @type {string}
     * @memberof Lead
     */
    'status'?: LeadStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof Lead
     */
    'company_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Lead
     */
    'company_id'?: string;
}

export const LeadStatusEnum = {
    Lost: 'lost',
    Open: 'open',
    Won: 'won'
} as const;

export type LeadStatusEnum = typeof LeadStatusEnum[keyof typeof LeadStatusEnum];

/**
 * 
 * @export
 * @interface LeadCreate
 */
export interface LeadCreate {
    /**
     * 
     * @type {string}
     * @memberof LeadCreate
     */
    'customer_id': string;
    /**
     * 
     * @type {string}
     * @memberof LeadCreate
     */
    'assigned_employee_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof LeadCreate
     */
    'address_id'?: string;
    /**
     * 
     * @type {LeadCreateAddress}
     * @memberof LeadCreate
     */
    'address'?: LeadCreateAddress;
    /**
     * 
     * @type {string}
     * @memberof LeadCreate
     */
    'lead_source'?: string;
    /**
     * 
     * @type {Array<LeadCreateLineItemsInner>}
     * @memberof LeadCreate
     */
    'line_items'?: Array<LeadCreateLineItemsInner>;
    /**
     * 
     * @type {string}
     * @memberof LeadCreate
     */
    'note'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof LeadCreate
     */
    'tags'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof LeadCreate
     */
    'tax_name'?: string;
    /**
     * 
     * @type {number}
     * @memberof LeadCreate
     */
    'tax_rate'?: number;
}
/**
 * 
 * @export
 * @interface LeadCreateAddress
 */
export interface LeadCreateAddress {
    /**
     * 
     * @type {string}
     * @memberof LeadCreateAddress
     */
    'city'?: string;
    /**
     * 
     * @type {string}
     * @memberof LeadCreateAddress
     */
    'state'?: string;
    /**
     * 
     * @type {string}
     * @memberof LeadCreateAddress
     */
    'street'?: string;
    /**
     * 
     * @type {string}
     * @memberof LeadCreateAddress
     */
    'street_line_2'?: string;
    /**
     * 
     * @type {string}
     * @memberof LeadCreateAddress
     */
    'zip'?: string;
}
/**
 * 
 * @export
 * @interface LeadCreateLineItemsInner
 */
export interface LeadCreateLineItemsInner {
    /**
     * 
     * @type {string}
     * @memberof LeadCreateLineItemsInner
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof LeadCreateLineItemsInner
     */
    'kind'?: LeadCreateLineItemsInnerKindEnum;
    /**
     * 
     * @type {string}
     * @memberof LeadCreateLineItemsInner
     */
    'name'?: string;
    /**
     * The number of items being solid. This can be a float up to two decmial places.
     * @type {number}
     * @memberof LeadCreateLineItemsInner
     */
    'quantity'?: number;
    /**
     * Direct cost to the company of a singe unit in cents. This value is used for job costing.
     * @type {number}
     * @memberof LeadCreateLineItemsInner
     */
    'unit_cost'?: number;
    /**
     * Selling price of a singe unit in cents.
     * @type {number}
     * @memberof LeadCreateLineItemsInner
     */
    'unit_price'?: number;
}

export const LeadCreateLineItemsInnerKindEnum = {
    Labor: 'labor',
    Materials: 'materials',
    FixedDiscount: 'fixed discount',
    PercentDiscount: 'percent discount'
} as const;

export type LeadCreateLineItemsInnerKindEnum = typeof LeadCreateLineItemsInnerKindEnum[keyof typeof LeadCreateLineItemsInnerKindEnum];

/**
 * 
 * @export
 * @interface LeadCustomer
 */
export interface LeadCustomer {
    /**
     * 
     * @type {string}
     * @memberof LeadCustomer
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof LeadCustomer
     */
    'first_name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof LeadCustomer
     */
    'last_name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof LeadCustomer
     */
    'email'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof LeadCustomer
     */
    'company'?: string | null;
    /**
     * Will the customer receive notifications
     * @type {boolean}
     * @memberof LeadCustomer
     */
    'notifications_enabled'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof LeadCustomer
     */
    'mobile_number'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof LeadCustomer
     */
    'home_number'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof LeadCustomer
     */
    'work_number'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof LeadCustomer
     */
    'tags'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof LeadCustomer
     */
    'lead_source'?: string | null;
}
/**
 * 
 * @export
 * @interface LeadLineItemsInner
 */
export interface LeadLineItemsInner {
    /**
     * 
     * @type {string}
     * @memberof LeadLineItemsInner
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof LeadLineItemsInner
     */
    'kind'?: LeadLineItemsInnerKindEnum;
    /**
     * 
     * @type {string}
     * @memberof LeadLineItemsInner
     */
    'name'?: string;
    /**
     * The number of items being solid. This can be a float up to two decmial places.
     * @type {number}
     * @memberof LeadLineItemsInner
     */
    'quantity'?: number;
    /**
     * Direct cost to the company of a singe unit in cents. This value is used for job costing.
     * @type {number}
     * @memberof LeadLineItemsInner
     */
    'unit_cost'?: number;
    /**
     * Selling price of a singe unit in cents.
     * @type {number}
     * @memberof LeadLineItemsInner
     */
    'unit_price'?: number;
}

export const LeadLineItemsInnerKindEnum = {
    Labor: 'labor',
    Materials: 'materials'
} as const;

export type LeadLineItemsInnerKindEnum = typeof LeadLineItemsInnerKindEnum[keyof typeof LeadLineItemsInnerKindEnum];

/**
 * 
 * @export
 * @interface LeadSource
 */
export interface LeadSource {
    /**
     * 
     * @type {string}
     * @memberof LeadSource
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof LeadSource
     */
    'name'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof LeadSource
     */
    'editable'?: boolean;
}
/**
 * 
 * @export
 * @interface LineItem
 */
export interface LineItem {
    /**
     * 
     * @type {string}
     * @memberof LineItem
     */
    'uuid'?: string;
    /**
     * 
     * @type {string}
     * @memberof LineItem
     */
    'service_item_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof LineItem
     */
    'service_item_type'?: string;
    /**
     * 
     * @type {string}
     * @memberof LineItem
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof LineItem
     */
    'unit_price'?: number;
    /**
     * 
     * @type {number}
     * @memberof LineItem
     */
    'unit_cost'?: number;
    /**
     * 
     * @type {number}
     * @memberof LineItem
     */
    'quantity'?: number;
    /**
     * 
     * @type {string}
     * @memberof LineItem
     */
    'kind'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof LineItem
     */
    'taxable'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof LineItem
     */
    'description'?: string;
}
/**
 * Object used to create a line on a job.
 * @export
 * @interface LineItemCreate
 */
export interface LineItemCreate {
    /**
     * 
     * @type {string}
     * @memberof LineItemCreate
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof LineItemCreate
     */
    'description'?: string;
    /**
     * Selling price of a singe unit in cents.
     * @type {number}
     * @memberof LineItemCreate
     */
    'unit_price'?: number;
    /**
     * The number of items being solid. This can be a float up to two decmial places.
     * @type {number}
     * @memberof LineItemCreate
     */
    'quantity'?: number;
    /**
     * Direct cost to the company of a singe unit in cents. This value is used for job costing.
     * @type {number}
     * @memberof LineItemCreate
     */
    'unit_cost'?: number;
}
/**
 * 
 * @export
 * @interface Material
 */
export interface Material {
    /**
     * 
     * @type {string}
     * @memberof Material
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Material
     */
    'uuid'?: string;
    /**
     * 
     * @type {string}
     * @memberof Material
     */
    'material_category_uuid'?: string;
    /**
     * 
     * @type {string}
     * @memberof Material
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Material
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof Material
     */
    'image'?: string;
    /**
     * 
     * @type {number}
     * @memberof Material
     */
    'cost'?: number;
    /**
     * 
     * @type {string}
     * @memberof Material
     */
    'unit_of_measure'?: string;
    /**
     * 
     * @type {string}
     * @memberof Material
     */
    'part_number'?: string;
    /**
     * 
     * @type {number}
     * @memberof Material
     */
    'price'?: number;
    /**
     * 
     * @type {string}
     * @memberof Material
     */
    'material_category_name'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Material
     */
    'taxable'?: boolean;
}
/**
 * 
 * @export
 * @interface MaterialCategory
 */
export interface MaterialCategory {
    /**
     * 
     * @type {string}
     * @memberof MaterialCategory
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof MaterialCategory
     */
    'uuid'?: string;
    /**
     * 
     * @type {string}
     * @memberof MaterialCategory
     */
    'material_category_uuid'?: string;
    /**
     * 
     * @type {string}
     * @memberof MaterialCategory
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof MaterialCategory
     */
    'image'?: string;
}
/**
 * 
 * @export
 * @interface Note
 */
export interface Note {
    /**
     * 
     * @type {string}
     * @memberof Note
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Note
     */
    'content'?: string;
}
/**
 * 
 * @export
 * @interface PaginatedList
 */
export interface PaginatedList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedList
     */
    'page': number;
    /**
     * 
     * @type {number}
     * @memberof PaginatedList
     */
    'page_size': number;
    /**
     * 
     * @type {number}
     * @memberof PaginatedList
     */
    'total_pages': number;
    /**
     * 
     * @type {number}
     * @memberof PaginatedList
     */
    'total_items': number;
}
/**
 * 
 * @export
 * @interface Phone
 */
export interface Phone {
    /**
     * 
     * @type {string}
     * @memberof Phone
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Phone
     */
    'number': string;
}
/**
 * 
 * @export
 * @interface PostJobsJobIdAttachments202Response
 */
export interface PostJobsJobIdAttachments202Response {
    /**
     * 
     * @type {string}
     * @memberof PostJobsJobIdAttachments202Response
     */
    'job_url'?: string;
}
/**
 * 
 * @export
 * @interface PostJobsJobIdNotesRequest
 */
export interface PostJobsJobIdNotesRequest {
    /**
     * 
     * @type {string}
     * @memberof PostJobsJobIdNotesRequest
     */
    'content': string;
}
/**
 * 
 * @export
 * @interface PostJobsJobIdTags201Response
 */
export interface PostJobsJobIdTags201Response {
    /**
     * 
     * @type {Array<Tag>}
     * @memberof PostJobsJobIdTags201Response
     */
    'tags'?: Array<Tag>;
}
/**
 * 
 * @export
 * @interface PostJobsJobIdTagsRequest
 */
export interface PostJobsJobIdTagsRequest {
    /**
     * 
     * @type {string}
     * @memberof PostJobsJobIdTagsRequest
     */
    'tag_id': string;
}
/**
 * 
 * @export
 * @interface PostLeadSourcesRequest
 */
export interface PostLeadSourcesRequest {
    /**
     * 
     * @type {string}
     * @memberof PostLeadSourcesRequest
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface PostTagsRequest
 */
export interface PostTagsRequest {
    /**
     * 
     * @type {string}
     * @memberof PostTagsRequest
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface PutEstimatesEstimateIdOptionsOptionIdSchedule200Response
 */
export interface PutEstimatesEstimateIdOptionsOptionIdSchedule200Response {
    /**
     * 
     * @type {string}
     * @memberof PutEstimatesEstimateIdOptionsOptionIdSchedule200Response
     */
    'start_time'?: string;
    /**
     * 
     * @type {string}
     * @memberof PutEstimatesEstimateIdOptionsOptionIdSchedule200Response
     */
    'end_time'?: string;
    /**
     * 
     * @type {number}
     * @memberof PutEstimatesEstimateIdOptionsOptionIdSchedule200Response
     */
    'arrival_window_mintues'?: number;
    /**
     * 
     * @type {Array<Employee>}
     * @memberof PutEstimatesEstimateIdOptionsOptionIdSchedule200Response
     */
    'assigned_employees'?: Array<Employee>;
}
/**
 * 
 * @export
 * @interface PutEstimatesEstimateIdOptionsOptionIdScheduleRequest
 */
export interface PutEstimatesEstimateIdOptionsOptionIdScheduleRequest {
    /**
     * Start time of estimate in iso8601
     * @type {string}
     * @memberof PutEstimatesEstimateIdOptionsOptionIdScheduleRequest
     */
    'start_time': string;
    /**
     * End time of estimate in iso8601
     * @type {string}
     * @memberof PutEstimatesEstimateIdOptionsOptionIdScheduleRequest
     */
    'end_time'?: string;
    /**
     * Integer value in minutes of arrival window
     * @type {number}
     * @memberof PutEstimatesEstimateIdOptionsOptionIdScheduleRequest
     */
    'arrival_window_in_minutes'?: number;
    /**
     * Notify the customer of the update schedule
     * @type {boolean}
     * @memberof PutEstimatesEstimateIdOptionsOptionIdScheduleRequest
     */
    'notify'?: boolean;
    /**
     * Notify the employee of the update schedule
     * @type {boolean}
     * @memberof PutEstimatesEstimateIdOptionsOptionIdScheduleRequest
     */
    'notify_pro'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof PutEstimatesEstimateIdOptionsOptionIdScheduleRequest
     */
    'expand'?: Array<string>;
    /**
     * 
     * @type {Array<PutEstimatesEstimateIdOptionsOptionIdScheduleRequestDispatchedEmployeesInner>}
     * @memberof PutEstimatesEstimateIdOptionsOptionIdScheduleRequest
     */
    'dispatched_employees'?: Array<PutEstimatesEstimateIdOptionsOptionIdScheduleRequestDispatchedEmployeesInner>;
}
/**
 * 
 * @export
 * @interface PutEstimatesEstimateIdOptionsOptionIdScheduleRequestDispatchedEmployeesInner
 */
export interface PutEstimatesEstimateIdOptionsOptionIdScheduleRequestDispatchedEmployeesInner {
    /**
     * 
     * @type {string}
     * @memberof PutEstimatesEstimateIdOptionsOptionIdScheduleRequestDispatchedEmployeesInner
     */
    'employee_id'?: string;
}
/**
 * 
 * @export
 * @interface Schedule
 */
export interface Schedule {
    /**
     * ISO-8601 formatted date string YYYY-MM-DD(2023-03-23)
     * @type {string}
     * @memberof Schedule
     */
    'scheduled_start'?: string;
    /**
     * ISO-8601 formatted date string YYYY-MM-DD(2023-03-23)
     * @type {string}
     * @memberof Schedule
     */
    'scheduled_end'?: string;
    /**
     * 
     * @type {number}
     * @memberof Schedule
     */
    'arrival_window'?: number;
    /**
     * Only present if expanded with appointments
     * @type {Array<Appointment>}
     * @memberof Schedule
     */
    'appointments'?: Array<Appointment>;
}
/**
 * 
 * @export
 * @interface Tag
 */
export interface Tag {
    /**
     * 
     * @type {string}
     * @memberof Tag
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Tag
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface UpdateCompanyScheduleAvailability400Response
 */
export interface UpdateCompanyScheduleAvailability400Response {
    /**
     * All errors formatted in a sentence
     * @type {string}
     * @memberof UpdateCompanyScheduleAvailability400Response
     */
    'message'?: string;
    /**
     * Error message for field attr1, where attr1 would be one of the attributes for the schedule availability object
     * @type {string}
     * @memberof UpdateCompanyScheduleAvailability400Response
     */
    'attr1'?: string;
}
/**
 * 
 * @export
 * @interface UpdateCompleteScheduleAvailability
 */
export interface UpdateCompleteScheduleAvailability {
    /**
     * 
     * @type {number}
     * @memberof UpdateCompleteScheduleAvailability
     */
    'availability_buffer_in_days': number;
    /**
     * 
     * @type {Array<UpdateCompleteScheduleAvailabilityDailyScheduleWindowsInner>}
     * @memberof UpdateCompleteScheduleAvailability
     */
    'daily_schedule_windows': Array<UpdateCompleteScheduleAvailabilityDailyScheduleWindowsInner>;
}
/**
 * 
 * @export
 * @interface UpdateCompleteScheduleAvailabilityDailyScheduleWindowsInner
 */
export interface UpdateCompleteScheduleAvailabilityDailyScheduleWindowsInner {
    /**
     * 
     * @type {string}
     * @memberof UpdateCompleteScheduleAvailabilityDailyScheduleWindowsInner
     */
    'day_name': string;
    /**
     * 
     * @type {Array<UpdateCompleteScheduleAvailabilityDailyScheduleWindowsInnerScheduleWindowsInner>}
     * @memberof UpdateCompleteScheduleAvailabilityDailyScheduleWindowsInner
     */
    'schedule_windows': Array<UpdateCompleteScheduleAvailabilityDailyScheduleWindowsInnerScheduleWindowsInner>;
}
/**
 * 
 * @export
 * @interface UpdateCompleteScheduleAvailabilityDailyScheduleWindowsInnerScheduleWindowsInner
 */
export interface UpdateCompleteScheduleAvailabilityDailyScheduleWindowsInnerScheduleWindowsInner {
    /**
     * ISO-8601 formatted date string
     * @type {string}
     * @memberof UpdateCompleteScheduleAvailabilityDailyScheduleWindowsInnerScheduleWindowsInner
     */
    'start_time': string;
    /**
     * ISO-8601 formatted date string
     * @type {string}
     * @memberof UpdateCompleteScheduleAvailabilityDailyScheduleWindowsInnerScheduleWindowsInner
     */
    'end_time': string;
}
/**
 * 
 * @export
 * @interface UpdateJobDispatch200Response
 */
export interface UpdateJobDispatch200Response {
    /**
     * 
     * @type {Array<Employee>}
     * @memberof UpdateJobDispatch200Response
     */
    'assigned_employees'?: Array<Employee>;
}
/**
 * 
 * @export
 * @interface UpdateJobDispatchRequest
 */
export interface UpdateJobDispatchRequest {
    /**
     * 
     * @type {Array<DispatchedEmployee>}
     * @memberof UpdateJobDispatchRequest
     */
    'dispatched_employees': Array<DispatchedEmployee>;
}
/**
 * 
 * @export
 * @interface UpdateJobLineItem400Response
 */
export interface UpdateJobLineItem400Response {
    /**
     * All errors formatted in a sentence
     * @type {string}
     * @memberof UpdateJobLineItem400Response
     */
    'message'?: string;
    /**
     * Error message for field attr1, where attr1 would be one of the attributes for line item
     * @type {string}
     * @memberof UpdateJobLineItem400Response
     */
    'attr1'?: string;
}
/**
 * 
 * @export
 * @interface UpdateJobSchedule200Response
 */
export interface UpdateJobSchedule200Response {
    /**
     * 
     * @type {string}
     * @memberof UpdateJobSchedule200Response
     */
    'start_time': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateJobSchedule200Response
     */
    'end_time': string;
    /**
     * 
     * @type {number}
     * @memberof UpdateJobSchedule200Response
     */
    'arrival_window_minutes': number;
    /**
     * 
     * @type {Array<Employee>}
     * @memberof UpdateJobSchedule200Response
     */
    'assigned_employees'?: Array<Employee>;
    /**
     * 
     * @type {Array<Appointment>}
     * @memberof UpdateJobSchedule200Response
     */
    'appointments'?: Array<Appointment>;
}
/**
 * 
 * @export
 * @interface UpdateJobScheduleRequest
 */
export interface UpdateJobScheduleRequest {
    /**
     * Start time of job in iso8601
     * @type {string}
     * @memberof UpdateJobScheduleRequest
     */
    'start_time': string;
    /**
     * End time of job in iso8601
     * @type {string}
     * @memberof UpdateJobScheduleRequest
     */
    'end_time'?: string;
    /**
     * Integer value in minutes of arrival window
     * @type {number}
     * @memberof UpdateJobScheduleRequest
     */
    'arrival_window_in_minutes'?: number;
    /**
     * Notify the customer of the update schedule
     * @type {boolean}
     * @memberof UpdateJobScheduleRequest
     */
    'notify'?: boolean;
    /**
     * Notify the employee of the update schedule
     * @type {boolean}
     * @memberof UpdateJobScheduleRequest
     */
    'notify_pro'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateJobScheduleRequest
     */
    'expand'?: Array<string>;
    /**
     * 
     * @type {Array<DispatchedEmployee>}
     * @memberof UpdateJobScheduleRequest
     */
    'dispatched_employees'?: Array<DispatchedEmployee>;
}
/**
 * 
 * @export
 * @interface UpdateMaterialRequest
 */
export interface UpdateMaterialRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateMaterialRequest
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateMaterialRequest
     */
    'description'?: string;
    /**
     * 
     * @type {number}
     * @memberof UpdateMaterialRequest
     */
    'price'?: number;
    /**
     * 
     * @type {number}
     * @memberof UpdateMaterialRequest
     */
    'cost'?: number;
    /**
     * 
     * @type {string}
     * @memberof UpdateMaterialRequest
     */
    'unit_of_measure'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateMaterialRequest
     */
    'part_number'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateMaterialRequest
     */
    'taxable'?: boolean;
}
/**
 * 
 * @export
 * @interface WorkTimestamps
 */
export interface WorkTimestamps {
    /**
     * ISO-8601 formatted date string YYYY-MM-DD(2023-03-23)
     * @type {string}
     * @memberof WorkTimestamps
     */
    'on_my_way_at'?: string | null;
    /**
     * ISO-8601 formatted date string YYYY-MM-DD(2023-03-23)
     * @type {string}
     * @memberof WorkTimestamps
     */
    'started_at'?: string | null;
    /**
     * ISO-8601 formatted date string YYYY-MM-DD(2023-03-23)
     * @type {string}
     * @memberof WorkTimestamps
     */
    'completed_at'?: string | null;
}

/**
 * ApplicationApi - axios parameter creator
 * @export
 */
export const ApplicationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get the application for a company.
         * @summary Get Application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplications: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/application`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApplicationAPIKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication HousecallUserOAuthToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "HousecallUserOAuthToken", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Disable the application for a company.
         * @summary Disable Application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postApplicationDisable: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/application/disable`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApplicationAPIKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication HousecallUserOAuthToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "HousecallUserOAuthToken", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Enable the application for a company.
         * @summary Enable Application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postApplicationEnable: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/application/enable`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApplicationAPIKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication HousecallUserOAuthToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "HousecallUserOAuthToken", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ApplicationApi - functional programming interface
 * @export
 */
export const ApplicationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ApplicationApiAxiosParamCreator(configuration)
    return {
        /**
         * Get the application for a company.
         * @summary Get Application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApplications(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Application>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApplications(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApplicationApi.getApplications']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Disable the application for a company.
         * @summary Disable Application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postApplicationDisable(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Application>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postApplicationDisable(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApplicationApi.postApplicationDisable']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Enable the application for a company.
         * @summary Enable Application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postApplicationEnable(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Application>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postApplicationEnable(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApplicationApi.postApplicationEnable']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ApplicationApi - factory interface
 * @export
 */
export const ApplicationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ApplicationApiFp(configuration)
    return {
        /**
         * Get the application for a company.
         * @summary Get Application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplications(options?: RawAxiosRequestConfig): AxiosPromise<Application> {
            return localVarFp.getApplications(options).then((request) => request(axios, basePath));
        },
        /**
         * Disable the application for a company.
         * @summary Disable Application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postApplicationDisable(options?: RawAxiosRequestConfig): AxiosPromise<Application> {
            return localVarFp.postApplicationDisable(options).then((request) => request(axios, basePath));
        },
        /**
         * Enable the application for a company.
         * @summary Enable Application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postApplicationEnable(options?: RawAxiosRequestConfig): AxiosPromise<Application> {
            return localVarFp.postApplicationEnable(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ApplicationApi - object-oriented interface
 * @export
 * @class ApplicationApi
 * @extends {BaseAPI}
 */
export class ApplicationApi extends BaseAPI {
    /**
     * Get the application for a company.
     * @summary Get Application
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApi
     */
    public getApplications(options?: RawAxiosRequestConfig) {
        return ApplicationApiFp(this.configuration).getApplications(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Disable the application for a company.
     * @summary Disable Application
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApi
     */
    public postApplicationDisable(options?: RawAxiosRequestConfig) {
        return ApplicationApiFp(this.configuration).postApplicationDisable(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Enable the application for a company.
     * @summary Enable Application
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApi
     */
    public postApplicationEnable(options?: RawAxiosRequestConfig) {
        return ApplicationApiFp(this.configuration).postApplicationEnable(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CompanyApi - axios parameter creator
 * @export
 */
export const CompanyApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get general company information
         * @summary Get Company
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCompany: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/company`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApplicationAPIKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication CompanyAPIKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication HousecallUserOAuthToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "HousecallUserOAuthToken", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CompanyApi - functional programming interface
 * @export
 */
export const CompanyApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CompanyApiAxiosParamCreator(configuration)
    return {
        /**
         * Get general company information
         * @summary Get Company
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCompany(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Company>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCompany(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CompanyApi.getCompany']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CompanyApi - factory interface
 * @export
 */
export const CompanyApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CompanyApiFp(configuration)
    return {
        /**
         * Get general company information
         * @summary Get Company
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCompany(options?: RawAxiosRequestConfig): AxiosPromise<Company> {
            return localVarFp.getCompany(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CompanyApi - object-oriented interface
 * @export
 * @class CompanyApi
 * @extends {BaseAPI}
 */
export class CompanyApi extends BaseAPI {
    /**
     * Get general company information
     * @summary Get Company
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CompanyApi
     */
    public getCompany(options?: RawAxiosRequestConfig) {
        return CompanyApiFp(this.configuration).getCompany(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CustomersApi - axios parameter creator
 * @export
 */
export const CustomersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get all of a customer\'s addresses
         * @summary Get All of a Customer\'s Addresses
         * @param {string} customerId 
         * @param {number} [page] Paginated page number.
         * @param {number} [pageSize] Number of addresses returned per page.
         * @param {GetCustomerCustomerIdAddressesSortByEnum} [sortBy] Address attribute to sort by
         * @param {GetCustomerCustomerIdAddressesSortDirectionEnum} [sortDirection] Ascending or descending
         * @param {GetCustomerCustomerIdAddressesRequest} [getCustomerCustomerIdAddressesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerCustomerIdAddresses: async (customerId: string, page?: number, pageSize?: number, sortBy?: GetCustomerCustomerIdAddressesSortByEnum, sortDirection?: GetCustomerCustomerIdAddressesSortDirectionEnum, getCustomerCustomerIdAddressesRequest?: GetCustomerCustomerIdAddressesRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerId' is not null or undefined
            assertParamExists('getCustomerCustomerIdAddresses', 'customerId', customerId)
            const localVarPath = `/customers/{customer_id}/addresses`
                .replace(`{${"customer_id"}}`, encodeURIComponent(String(customerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (sortDirection !== undefined) {
                localVarQueryParameter['sort_direction'] = sortDirection;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getCustomerCustomerIdAddressesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the customer via ID.
         * @summary Get Customer
         * @param {string} customerId 
         * @param {Array<GetCustomersCustomerIdExpandEnum>} [expand] Array of strings to expand response body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomersCustomerId: async (customerId: string, expand?: Array<GetCustomersCustomerIdExpandEnum>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerId' is not null or undefined
            assertParamExists('getCustomersCustomerId', 'customerId', customerId)
            const localVarPath = `/customers/{customer_id}`
                .replace(`{${"customer_id"}}`, encodeURIComponent(String(customerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApplicationAPIKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication CompanyAPIKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication HousecallUserOAuthToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "HousecallUserOAuthToken", [], configuration)

            if (expand) {
                localVarQueryParameter['expand'] = expand;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a customer\'s address via customer ID and address ID.
         * @summary Get a Customer\'s Address
         * @param {string} customerId 
         * @param {string} addressId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomersCustomerIdAddressesAddressId: async (customerId: string, addressId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerId' is not null or undefined
            assertParamExists('getCustomersCustomerIdAddressesAddressId', 'customerId', customerId)
            // verify required parameter 'addressId' is not null or undefined
            assertParamExists('getCustomersCustomerIdAddressesAddressId', 'addressId', addressId)
            const localVarPath = `/customers/{customer_id}/addresses/{address_id}`
                .replace(`{${"customer_id"}}`, encodeURIComponent(String(customerId)))
                .replace(`{${"address_id"}}`, encodeURIComponent(String(addressId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApplicationAPIKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication CompanyAPIKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication HousecallUserOAuthToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "HousecallUserOAuthToken", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of customers.
         * @summary Get Customers
         * @param {string} [q] A query that can be used to search for a customer by name, email, mobile number and address.
         * @param {number} [page] Current Page
         * @param {number} [pageSize] Number of customers per page
         * @param {GetV1CustomersSortByEnum} [sortBy] Customer attribute to sort by
         * @param {GetV1CustomersSortDirectionEnum} [sortDirection] Ascending or descending
         * @param {Array<string>} [locationIds] Id of locations you want to pull from
         * @param {Array<GetV1CustomersExpandEnum>} [expand] Array of strings to expand response body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getV1Customers: async (q?: string, page?: number, pageSize?: number, sortBy?: GetV1CustomersSortByEnum, sortDirection?: GetV1CustomersSortDirectionEnum, locationIds?: Array<string>, expand?: Array<GetV1CustomersExpandEnum>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/customers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApplicationAPIKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication CompanyAPIKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication HousecallUserOAuthToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "HousecallUserOAuthToken", [], configuration)

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (sortDirection !== undefined) {
                localVarQueryParameter['sort_direction'] = sortDirection;
            }

            if (locationIds) {
                localVarQueryParameter['location_ids'] = locationIds;
            }

            if (expand) {
                localVarQueryParameter['expand'] = expand;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create an address on a customer
         * @summary Create an Address on a Customer
         * @param {string} customerId 
         * @param {AddressCreate} [addressCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCustomerCustomerIdAddresses: async (customerId: string, addressCreate?: AddressCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerId' is not null or undefined
            assertParamExists('postCustomerCustomerIdAddresses', 'customerId', customerId)
            const localVarPath = `/customers/{customer_id}/addresses`
                .replace(`{${"customer_id"}}`, encodeURIComponent(String(customerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addressCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new Customer.
         * @summary Create Customer
         * @param {CustomerCreate} [customerCreate] One of first_name, last_name, email, mobile_number, home_number, work_number are required.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCustomers: async (customerCreate?: CustomerCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/customers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApplicationAPIKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication CompanyAPIKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication HousecallUserOAuthToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "HousecallUserOAuthToken", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(customerCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update customer attributes
         * @summary Update Customer
         * @param {string} customerId 
         * @param {CustomerUpdate} [customerUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putCustomersCustomerId: async (customerId: string, customerUpdate?: CustomerUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerId' is not null or undefined
            assertParamExists('putCustomersCustomerId', 'customerId', customerId)
            const localVarPath = `/customers/{customer_id}`
                .replace(`{${"customer_id"}}`, encodeURIComponent(String(customerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApplicationAPIKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication CompanyAPIKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication HousecallUserOAuthToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "HousecallUserOAuthToken", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(customerUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CustomersApi - functional programming interface
 * @export
 */
export const CustomersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CustomersApiAxiosParamCreator(configuration)
    return {
        /**
         * Get all of a customer\'s addresses
         * @summary Get All of a Customer\'s Addresses
         * @param {string} customerId 
         * @param {number} [page] Paginated page number.
         * @param {number} [pageSize] Number of addresses returned per page.
         * @param {GetCustomerCustomerIdAddressesSortByEnum} [sortBy] Address attribute to sort by
         * @param {GetCustomerCustomerIdAddressesSortDirectionEnum} [sortDirection] Ascending or descending
         * @param {GetCustomerCustomerIdAddressesRequest} [getCustomerCustomerIdAddressesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCustomerCustomerIdAddresses(customerId: string, page?: number, pageSize?: number, sortBy?: GetCustomerCustomerIdAddressesSortByEnum, sortDirection?: GetCustomerCustomerIdAddressesSortDirectionEnum, getCustomerCustomerIdAddressesRequest?: GetCustomerCustomerIdAddressesRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCustomerCustomerIdAddresses(customerId, page, pageSize, sortBy, sortDirection, getCustomerCustomerIdAddressesRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CustomersApi.getCustomerCustomerIdAddresses']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the customer via ID.
         * @summary Get Customer
         * @param {string} customerId 
         * @param {Array<GetCustomersCustomerIdExpandEnum>} [expand] Array of strings to expand response body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCustomersCustomerId(customerId: string, expand?: Array<GetCustomersCustomerIdExpandEnum>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Customer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCustomersCustomerId(customerId, expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CustomersApi.getCustomersCustomerId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a customer\'s address via customer ID and address ID.
         * @summary Get a Customer\'s Address
         * @param {string} customerId 
         * @param {string} addressId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCustomersCustomerIdAddressesAddressId(customerId: string, addressId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Address>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCustomersCustomerIdAddressesAddressId(customerId, addressId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CustomersApi.getCustomersCustomerIdAddressesAddressId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a list of customers.
         * @summary Get Customers
         * @param {string} [q] A query that can be used to search for a customer by name, email, mobile number and address.
         * @param {number} [page] Current Page
         * @param {number} [pageSize] Number of customers per page
         * @param {GetV1CustomersSortByEnum} [sortBy] Customer attribute to sort by
         * @param {GetV1CustomersSortDirectionEnum} [sortDirection] Ascending or descending
         * @param {Array<string>} [locationIds] Id of locations you want to pull from
         * @param {Array<GetV1CustomersExpandEnum>} [expand] Array of strings to expand response body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getV1Customers(q?: string, page?: number, pageSize?: number, sortBy?: GetV1CustomersSortByEnum, sortDirection?: GetV1CustomersSortDirectionEnum, locationIds?: Array<string>, expand?: Array<GetV1CustomersExpandEnum>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetV1Customers200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getV1Customers(q, page, pageSize, sortBy, sortDirection, locationIds, expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CustomersApi.getV1Customers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create an address on a customer
         * @summary Create an Address on a Customer
         * @param {string} customerId 
         * @param {AddressCreate} [addressCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postCustomerCustomerIdAddresses(customerId: string, addressCreate?: AddressCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Address>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postCustomerCustomerIdAddresses(customerId, addressCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CustomersApi.postCustomerCustomerIdAddresses']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new Customer.
         * @summary Create Customer
         * @param {CustomerCreate} [customerCreate] One of first_name, last_name, email, mobile_number, home_number, work_number are required.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postCustomers(customerCreate?: CustomerCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Customer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postCustomers(customerCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CustomersApi.postCustomers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update customer attributes
         * @summary Update Customer
         * @param {string} customerId 
         * @param {CustomerUpdate} [customerUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putCustomersCustomerId(customerId: string, customerUpdate?: CustomerUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Customer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putCustomersCustomerId(customerId, customerUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CustomersApi.putCustomersCustomerId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CustomersApi - factory interface
 * @export
 */
export const CustomersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CustomersApiFp(configuration)
    return {
        /**
         * Get all of a customer\'s addresses
         * @summary Get All of a Customer\'s Addresses
         * @param {string} customerId 
         * @param {number} [page] Paginated page number.
         * @param {number} [pageSize] Number of addresses returned per page.
         * @param {GetCustomerCustomerIdAddressesSortByEnum} [sortBy] Address attribute to sort by
         * @param {GetCustomerCustomerIdAddressesSortDirectionEnum} [sortDirection] Ascending or descending
         * @param {GetCustomerCustomerIdAddressesRequest} [getCustomerCustomerIdAddressesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerCustomerIdAddresses(customerId: string, page?: number, pageSize?: number, sortBy?: GetCustomerCustomerIdAddressesSortByEnum, sortDirection?: GetCustomerCustomerIdAddressesSortDirectionEnum, getCustomerCustomerIdAddressesRequest?: GetCustomerCustomerIdAddressesRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.getCustomerCustomerIdAddresses(customerId, page, pageSize, sortBy, sortDirection, getCustomerCustomerIdAddressesRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the customer via ID.
         * @summary Get Customer
         * @param {string} customerId 
         * @param {Array<GetCustomersCustomerIdExpandEnum>} [expand] Array of strings to expand response body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomersCustomerId(customerId: string, expand?: Array<GetCustomersCustomerIdExpandEnum>, options?: RawAxiosRequestConfig): AxiosPromise<Customer> {
            return localVarFp.getCustomersCustomerId(customerId, expand, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a customer\'s address via customer ID and address ID.
         * @summary Get a Customer\'s Address
         * @param {string} customerId 
         * @param {string} addressId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomersCustomerIdAddressesAddressId(customerId: string, addressId: string, options?: RawAxiosRequestConfig): AxiosPromise<Address> {
            return localVarFp.getCustomersCustomerIdAddressesAddressId(customerId, addressId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of customers.
         * @summary Get Customers
         * @param {string} [q] A query that can be used to search for a customer by name, email, mobile number and address.
         * @param {number} [page] Current Page
         * @param {number} [pageSize] Number of customers per page
         * @param {GetV1CustomersSortByEnum} [sortBy] Customer attribute to sort by
         * @param {GetV1CustomersSortDirectionEnum} [sortDirection] Ascending or descending
         * @param {Array<string>} [locationIds] Id of locations you want to pull from
         * @param {Array<GetV1CustomersExpandEnum>} [expand] Array of strings to expand response body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getV1Customers(q?: string, page?: number, pageSize?: number, sortBy?: GetV1CustomersSortByEnum, sortDirection?: GetV1CustomersSortDirectionEnum, locationIds?: Array<string>, expand?: Array<GetV1CustomersExpandEnum>, options?: RawAxiosRequestConfig): AxiosPromise<GetV1Customers200Response> {
            return localVarFp.getV1Customers(q, page, pageSize, sortBy, sortDirection, locationIds, expand, options).then((request) => request(axios, basePath));
        },
        /**
         * Create an address on a customer
         * @summary Create an Address on a Customer
         * @param {string} customerId 
         * @param {AddressCreate} [addressCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCustomerCustomerIdAddresses(customerId: string, addressCreate?: AddressCreate, options?: RawAxiosRequestConfig): AxiosPromise<Address> {
            return localVarFp.postCustomerCustomerIdAddresses(customerId, addressCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new Customer.
         * @summary Create Customer
         * @param {CustomerCreate} [customerCreate] One of first_name, last_name, email, mobile_number, home_number, work_number are required.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCustomers(customerCreate?: CustomerCreate, options?: RawAxiosRequestConfig): AxiosPromise<Customer> {
            return localVarFp.postCustomers(customerCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * Update customer attributes
         * @summary Update Customer
         * @param {string} customerId 
         * @param {CustomerUpdate} [customerUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putCustomersCustomerId(customerId: string, customerUpdate?: CustomerUpdate, options?: RawAxiosRequestConfig): AxiosPromise<Customer> {
            return localVarFp.putCustomersCustomerId(customerId, customerUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CustomersApi - object-oriented interface
 * @export
 * @class CustomersApi
 * @extends {BaseAPI}
 */
export class CustomersApi extends BaseAPI {
    /**
     * Get all of a customer\'s addresses
     * @summary Get All of a Customer\'s Addresses
     * @param {string} customerId 
     * @param {number} [page] Paginated page number.
     * @param {number} [pageSize] Number of addresses returned per page.
     * @param {GetCustomerCustomerIdAddressesSortByEnum} [sortBy] Address attribute to sort by
     * @param {GetCustomerCustomerIdAddressesSortDirectionEnum} [sortDirection] Ascending or descending
     * @param {GetCustomerCustomerIdAddressesRequest} [getCustomerCustomerIdAddressesRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomersApi
     */
    public getCustomerCustomerIdAddresses(customerId: string, page?: number, pageSize?: number, sortBy?: GetCustomerCustomerIdAddressesSortByEnum, sortDirection?: GetCustomerCustomerIdAddressesSortDirectionEnum, getCustomerCustomerIdAddressesRequest?: GetCustomerCustomerIdAddressesRequest, options?: RawAxiosRequestConfig) {
        return CustomersApiFp(this.configuration).getCustomerCustomerIdAddresses(customerId, page, pageSize, sortBy, sortDirection, getCustomerCustomerIdAddressesRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the customer via ID.
     * @summary Get Customer
     * @param {string} customerId 
     * @param {Array<GetCustomersCustomerIdExpandEnum>} [expand] Array of strings to expand response body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomersApi
     */
    public getCustomersCustomerId(customerId: string, expand?: Array<GetCustomersCustomerIdExpandEnum>, options?: RawAxiosRequestConfig) {
        return CustomersApiFp(this.configuration).getCustomersCustomerId(customerId, expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a customer\'s address via customer ID and address ID.
     * @summary Get a Customer\'s Address
     * @param {string} customerId 
     * @param {string} addressId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomersApi
     */
    public getCustomersCustomerIdAddressesAddressId(customerId: string, addressId: string, options?: RawAxiosRequestConfig) {
        return CustomersApiFp(this.configuration).getCustomersCustomerIdAddressesAddressId(customerId, addressId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of customers.
     * @summary Get Customers
     * @param {string} [q] A query that can be used to search for a customer by name, email, mobile number and address.
     * @param {number} [page] Current Page
     * @param {number} [pageSize] Number of customers per page
     * @param {GetV1CustomersSortByEnum} [sortBy] Customer attribute to sort by
     * @param {GetV1CustomersSortDirectionEnum} [sortDirection] Ascending or descending
     * @param {Array<string>} [locationIds] Id of locations you want to pull from
     * @param {Array<GetV1CustomersExpandEnum>} [expand] Array of strings to expand response body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomersApi
     */
    public getV1Customers(q?: string, page?: number, pageSize?: number, sortBy?: GetV1CustomersSortByEnum, sortDirection?: GetV1CustomersSortDirectionEnum, locationIds?: Array<string>, expand?: Array<GetV1CustomersExpandEnum>, options?: RawAxiosRequestConfig) {
        return CustomersApiFp(this.configuration).getV1Customers(q, page, pageSize, sortBy, sortDirection, locationIds, expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create an address on a customer
     * @summary Create an Address on a Customer
     * @param {string} customerId 
     * @param {AddressCreate} [addressCreate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomersApi
     */
    public postCustomerCustomerIdAddresses(customerId: string, addressCreate?: AddressCreate, options?: RawAxiosRequestConfig) {
        return CustomersApiFp(this.configuration).postCustomerCustomerIdAddresses(customerId, addressCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new Customer.
     * @summary Create Customer
     * @param {CustomerCreate} [customerCreate] One of first_name, last_name, email, mobile_number, home_number, work_number are required.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomersApi
     */
    public postCustomers(customerCreate?: CustomerCreate, options?: RawAxiosRequestConfig) {
        return CustomersApiFp(this.configuration).postCustomers(customerCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update customer attributes
     * @summary Update Customer
     * @param {string} customerId 
     * @param {CustomerUpdate} [customerUpdate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomersApi
     */
    public putCustomersCustomerId(customerId: string, customerUpdate?: CustomerUpdate, options?: RawAxiosRequestConfig) {
        return CustomersApiFp(this.configuration).putCustomersCustomerId(customerId, customerUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const GetCustomerCustomerIdAddressesSortByEnum = {
    CreatedAt: 'created_at',
    UpdatedAt: 'updated_at'
} as const;
export type GetCustomerCustomerIdAddressesSortByEnum = typeof GetCustomerCustomerIdAddressesSortByEnum[keyof typeof GetCustomerCustomerIdAddressesSortByEnum];
/**
 * @export
 */
export const GetCustomerCustomerIdAddressesSortDirectionEnum = {
    Desc: 'desc',
    Asc: 'asc'
} as const;
export type GetCustomerCustomerIdAddressesSortDirectionEnum = typeof GetCustomerCustomerIdAddressesSortDirectionEnum[keyof typeof GetCustomerCustomerIdAddressesSortDirectionEnum];
/**
 * @export
 */
export const GetCustomersCustomerIdExpandEnum = {
    Attachments: 'attachments'
} as const;
export type GetCustomersCustomerIdExpandEnum = typeof GetCustomersCustomerIdExpandEnum[keyof typeof GetCustomersCustomerIdExpandEnum];
/**
 * @export
 */
export const GetV1CustomersSortByEnum = {
    CreatedAt: 'created_at'
} as const;
export type GetV1CustomersSortByEnum = typeof GetV1CustomersSortByEnum[keyof typeof GetV1CustomersSortByEnum];
/**
 * @export
 */
export const GetV1CustomersSortDirectionEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type GetV1CustomersSortDirectionEnum = typeof GetV1CustomersSortDirectionEnum[keyof typeof GetV1CustomersSortDirectionEnum];
/**
 * @export
 */
export const GetV1CustomersExpandEnum = {
    Attachments: 'attachments'
} as const;
export type GetV1CustomersExpandEnum = typeof GetV1CustomersExpandEnum[keyof typeof GetV1CustomersExpandEnum];


/**
 * EmployeesApi - axios parameter creator
 * @export
 */
export const EmployeesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get all of the active employees in an organiztion. 
         * @summary Get Employees
         * @param {number} [page] Current page
         * @param {number} [pageSize] Number of employees per page
         * @param {string} [sortBy] employee attribute to sort_by
         * @param {string} [sortDirection] Ascending or descending
         * @param {Array<string>} [locationIds] Id of locations you want to pull from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmployees: async (page?: number, pageSize?: number, sortBy?: string, sortDirection?: string, locationIds?: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/employees`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApplicationAPIKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication CompanyAPIKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication HousecallUserOAuthToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "HousecallUserOAuthToken", [], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (sortDirection !== undefined) {
                localVarQueryParameter['sort_direction'] = sortDirection;
            }

            if (locationIds) {
                localVarQueryParameter['location_ids'] = locationIds;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EmployeesApi - functional programming interface
 * @export
 */
export const EmployeesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EmployeesApiAxiosParamCreator(configuration)
    return {
        /**
         * Get all of the active employees in an organiztion. 
         * @summary Get Employees
         * @param {number} [page] Current page
         * @param {number} [pageSize] Number of employees per page
         * @param {string} [sortBy] employee attribute to sort_by
         * @param {string} [sortDirection] Ascending or descending
         * @param {Array<string>} [locationIds] Id of locations you want to pull from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEmployees(page?: number, pageSize?: number, sortBy?: string, sortDirection?: string, locationIds?: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetEmployees200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEmployees(page, pageSize, sortBy, sortDirection, locationIds, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EmployeesApi.getEmployees']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * EmployeesApi - factory interface
 * @export
 */
export const EmployeesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EmployeesApiFp(configuration)
    return {
        /**
         * Get all of the active employees in an organiztion. 
         * @summary Get Employees
         * @param {number} [page] Current page
         * @param {number} [pageSize] Number of employees per page
         * @param {string} [sortBy] employee attribute to sort_by
         * @param {string} [sortDirection] Ascending or descending
         * @param {Array<string>} [locationIds] Id of locations you want to pull from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmployees(page?: number, pageSize?: number, sortBy?: string, sortDirection?: string, locationIds?: Array<string>, options?: RawAxiosRequestConfig): AxiosPromise<GetEmployees200Response> {
            return localVarFp.getEmployees(page, pageSize, sortBy, sortDirection, locationIds, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EmployeesApi - object-oriented interface
 * @export
 * @class EmployeesApi
 * @extends {BaseAPI}
 */
export class EmployeesApi extends BaseAPI {
    /**
     * Get all of the active employees in an organiztion. 
     * @summary Get Employees
     * @param {number} [page] Current page
     * @param {number} [pageSize] Number of employees per page
     * @param {string} [sortBy] employee attribute to sort_by
     * @param {string} [sortDirection] Ascending or descending
     * @param {Array<string>} [locationIds] Id of locations you want to pull from
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmployeesApi
     */
    public getEmployees(page?: number, pageSize?: number, sortBy?: string, sortDirection?: string, locationIds?: Array<string>, options?: RawAxiosRequestConfig) {
        return EmployeesApiFp(this.configuration).getEmployees(page, pageSize, sortBy, sortDirection, locationIds, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * EstimatesApi - axios parameter creator
 * @export
 */
export const EstimatesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new estimate option attachment
         * @summary Create Estimate option attachment
         * @param {string} estimateId 
         * @param {string} optionId 
         * @param {File} file A binary file from your local machine
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEstimateOptionAttachment: async (estimateId: string, optionId: string, file: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'estimateId' is not null or undefined
            assertParamExists('createEstimateOptionAttachment', 'estimateId', estimateId)
            // verify required parameter 'optionId' is not null or undefined
            assertParamExists('createEstimateOptionAttachment', 'optionId', optionId)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('createEstimateOptionAttachment', 'file', file)
            const localVarPath = `/estimates/{estimate_id}/options/{option_id}/attachments`
                .replace(`{${"estimate_id"}}`, encodeURIComponent(String(estimateId)))
                .replace(`{${"option_id"}}`, encodeURIComponent(String(optionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication CompanyAPIKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication HousecallUserOAuthToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "HousecallUserOAuthToken", [], configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new estimate option link
         * @summary Create Estimate option link
         * @param {string} estimateId 
         * @param {string} optionId 
         * @param {JobLinkCreate} [jobLinkCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEstimateOptionLink: async (estimateId: string, optionId: string, jobLinkCreate?: JobLinkCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'estimateId' is not null or undefined
            assertParamExists('createEstimateOptionLink', 'estimateId', estimateId)
            // verify required parameter 'optionId' is not null or undefined
            assertParamExists('createEstimateOptionLink', 'optionId', optionId)
            const localVarPath = `/estimates/{estimate_id}/options/{option_id}/links`
                .replace(`{${"estimate_id"}}`, encodeURIComponent(String(estimateId)))
                .replace(`{${"option_id"}}`, encodeURIComponent(String(optionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CompanyAPIKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication HousecallUserOAuthToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "HousecallUserOAuthToken", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(jobLinkCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new estimate option note
         * @summary Create Estimate option note
         * @param {string} estimateId 
         * @param {string} optionId 
         * @param {PostJobsJobIdNotesRequest} [postJobsJobIdNotesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEstimateOptionNote: async (estimateId: string, optionId: string, postJobsJobIdNotesRequest?: PostJobsJobIdNotesRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'estimateId' is not null or undefined
            assertParamExists('createEstimateOptionNote', 'estimateId', estimateId)
            // verify required parameter 'optionId' is not null or undefined
            assertParamExists('createEstimateOptionNote', 'optionId', optionId)
            const localVarPath = `/estimates/{estimate_id}/options/{option_id}/notes`
                .replace(`{${"estimate_id"}}`, encodeURIComponent(String(estimateId)))
                .replace(`{${"option_id"}}`, encodeURIComponent(String(optionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CompanyAPIKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication HousecallUserOAuthToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "HousecallUserOAuthToken", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postJobsJobIdNotesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a specific estimate option note
         * @summary Delete estimate option note
         * @param {string} estimateId 
         * @param {string} optionId 
         * @param {string} noteId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEstimatesEstimateIdOptionsOptionIdNotes: async (estimateId: string, optionId: string, noteId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'estimateId' is not null or undefined
            assertParamExists('deleteEstimatesEstimateIdOptionsOptionIdNotes', 'estimateId', estimateId)
            // verify required parameter 'optionId' is not null or undefined
            assertParamExists('deleteEstimatesEstimateIdOptionsOptionIdNotes', 'optionId', optionId)
            // verify required parameter 'noteId' is not null or undefined
            assertParamExists('deleteEstimatesEstimateIdOptionsOptionIdNotes', 'noteId', noteId)
            const localVarPath = `/estimates/{estimate_id}/options/{option_id}/notes/{note_id}`
                .replace(`{${"estimate_id"}}`, encodeURIComponent(String(estimateId)))
                .replace(`{${"option_id"}}`, encodeURIComponent(String(optionId)))
                .replace(`{${"note_id"}}`, encodeURIComponent(String(noteId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CompanyAPIKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication HousecallUserOAuthToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "HousecallUserOAuthToken", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a single estimate by ID
         * @param {string} estimateId 
         * @param {Array<EstimatesEstimateIdGetExpandEnum>} [expand] Array of strings to expand response body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        estimatesEstimateIdGet: async (estimateId: string, expand?: Array<EstimatesEstimateIdGetExpandEnum>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'estimateId' is not null or undefined
            assertParamExists('estimatesEstimateIdGet', 'estimateId', estimateId)
            const localVarPath = `/estimates/{estimate_id}`
                .replace(`{${"estimate_id"}}`, encodeURIComponent(String(estimateId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApplicationAPIKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication HousecallUserOAuthToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "HousecallUserOAuthToken", [], configuration)

            if (expand) {
                localVarQueryParameter['expand'] = expand;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of estimates
         * @summary Get Estimates
         * @param {string} [scheduledStartMin] Filters estimates with a starting time greater than or equal to the date sent.
         * @param {string} [scheduledStartMax] Filters estimates with a starting time less than or equal to the date sent.
         * @param {string} [scheduledEndMin] Filters estimates with an end time greater than or equal to the date sent.
         * @param {string} [scheduledEndMax] Filters estimates with an end time less than or equal to the date sent.
         * @param {Array<string>} [employeeIds] Filters estimates by assigned pro id
         * @param {string} [customerId] Filters estimates by a single customer ID (string)
         * @param {string} [page] Paginated page number.
         * @param {Array<GetEstiamtesWorkStatusEnum>} [workStatus] Work status filter. Returns estimates from all statuses if empty.
         * @param {number} [pageSize] Number of estimates returned per page.
         * @param {GetEstiamtesSortDirectionEnum} [sortDirection] Order of estimates returned.
         * @param {Array<string>} [locationIds] Id of locations you want to pull from
         * @param {Array<GetEstiamtesExpandEnum>} [expand] Array of strings to expand response body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEstiamtes: async (scheduledStartMin?: string, scheduledStartMax?: string, scheduledEndMin?: string, scheduledEndMax?: string, employeeIds?: Array<string>, customerId?: string, page?: string, workStatus?: Array<GetEstiamtesWorkStatusEnum>, pageSize?: number, sortDirection?: GetEstiamtesSortDirectionEnum, locationIds?: Array<string>, expand?: Array<GetEstiamtesExpandEnum>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/estimates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (scheduledStartMin !== undefined) {
                localVarQueryParameter['scheduled_start_min'] = scheduledStartMin;
            }

            if (scheduledStartMax !== undefined) {
                localVarQueryParameter['scheduled_start_max'] = scheduledStartMax;
            }

            if (scheduledEndMin !== undefined) {
                localVarQueryParameter['scheduled_end_min'] = scheduledEndMin;
            }

            if (scheduledEndMax !== undefined) {
                localVarQueryParameter['scheduled_end_max'] = scheduledEndMax;
            }

            if (employeeIds) {
                localVarQueryParameter['employee_ids'] = employeeIds;
            }

            if (customerId !== undefined) {
                localVarQueryParameter['customer_id'] = customerId;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (workStatus) {
                localVarQueryParameter['work_status'] = workStatus;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (sortDirection !== undefined) {
                localVarQueryParameter['sort_direction'] = sortDirection;
            }

            if (locationIds) {
                localVarQueryParameter['location_ids'] = locationIds;
            }

            if (expand) {
                localVarQueryParameter['expand'] = expand;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create an estimate
         * @summary Create an estimate
         * @param {EstimateCreate} [estimateCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postEstimates: async (estimateCreate?: EstimateCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/estimates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(estimateCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an estimate option schedule.
         * @summary Update estimate option schedule
         * @param {string} estimateId 
         * @param {string} optionId 
         * @param {PutEstimatesEstimateIdOptionsOptionIdScheduleRequest} [putEstimatesEstimateIdOptionsOptionIdScheduleRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putEstimatesEstimateIdOptionsOptionIdSchedule: async (estimateId: string, optionId: string, putEstimatesEstimateIdOptionsOptionIdScheduleRequest?: PutEstimatesEstimateIdOptionsOptionIdScheduleRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'estimateId' is not null or undefined
            assertParamExists('putEstimatesEstimateIdOptionsOptionIdSchedule', 'estimateId', estimateId)
            // verify required parameter 'optionId' is not null or undefined
            assertParamExists('putEstimatesEstimateIdOptionsOptionIdSchedule', 'optionId', optionId)
            const localVarPath = `/estimates/{estimate_id}/options/{option_id}/schedule`
                .replace(`{${"estimate_id"}}`, encodeURIComponent(String(estimateId)))
                .replace(`{${"option_id"}}`, encodeURIComponent(String(optionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CompanyAPIKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication HousecallUserOAuthToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "HousecallUserOAuthToken", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(putEstimatesEstimateIdOptionsOptionIdScheduleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EstimatesApi - functional programming interface
 * @export
 */
export const EstimatesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EstimatesApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new estimate option attachment
         * @summary Create Estimate option attachment
         * @param {string} estimateId 
         * @param {string} optionId 
         * @param {File} file A binary file from your local machine
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEstimateOptionAttachment(estimateId: string, optionId: string, file: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateEstimateOptionAttachment202Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEstimateOptionAttachment(estimateId, optionId, file, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EstimatesApi.createEstimateOptionAttachment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new estimate option link
         * @summary Create Estimate option link
         * @param {string} estimateId 
         * @param {string} optionId 
         * @param {JobLinkCreate} [jobLinkCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEstimateOptionLink(estimateId: string, optionId: string, jobLinkCreate?: JobLinkCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JobLink>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEstimateOptionLink(estimateId, optionId, jobLinkCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EstimatesApi.createEstimateOptionLink']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new estimate option note
         * @summary Create Estimate option note
         * @param {string} estimateId 
         * @param {string} optionId 
         * @param {PostJobsJobIdNotesRequest} [postJobsJobIdNotesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEstimateOptionNote(estimateId: string, optionId: string, postJobsJobIdNotesRequest?: PostJobsJobIdNotesRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Note>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEstimateOptionNote(estimateId, optionId, postJobsJobIdNotesRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EstimatesApi.createEstimateOptionNote']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a specific estimate option note
         * @summary Delete estimate option note
         * @param {string} estimateId 
         * @param {string} optionId 
         * @param {string} noteId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEstimatesEstimateIdOptionsOptionIdNotes(estimateId: string, optionId: string, noteId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEstimatesEstimateIdOptionsOptionIdNotes(estimateId, optionId, noteId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EstimatesApi.deleteEstimatesEstimateIdOptionsOptionIdNotes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a single estimate by ID
         * @param {string} estimateId 
         * @param {Array<EstimatesEstimateIdGetExpandEnum>} [expand] Array of strings to expand response body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async estimatesEstimateIdGet(estimateId: string, expand?: Array<EstimatesEstimateIdGetExpandEnum>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Estimate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.estimatesEstimateIdGet(estimateId, expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EstimatesApi.estimatesEstimateIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a list of estimates
         * @summary Get Estimates
         * @param {string} [scheduledStartMin] Filters estimates with a starting time greater than or equal to the date sent.
         * @param {string} [scheduledStartMax] Filters estimates with a starting time less than or equal to the date sent.
         * @param {string} [scheduledEndMin] Filters estimates with an end time greater than or equal to the date sent.
         * @param {string} [scheduledEndMax] Filters estimates with an end time less than or equal to the date sent.
         * @param {Array<string>} [employeeIds] Filters estimates by assigned pro id
         * @param {string} [customerId] Filters estimates by a single customer ID (string)
         * @param {string} [page] Paginated page number.
         * @param {Array<GetEstiamtesWorkStatusEnum>} [workStatus] Work status filter. Returns estimates from all statuses if empty.
         * @param {number} [pageSize] Number of estimates returned per page.
         * @param {GetEstiamtesSortDirectionEnum} [sortDirection] Order of estimates returned.
         * @param {Array<string>} [locationIds] Id of locations you want to pull from
         * @param {Array<GetEstiamtesExpandEnum>} [expand] Array of strings to expand response body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEstiamtes(scheduledStartMin?: string, scheduledStartMax?: string, scheduledEndMin?: string, scheduledEndMax?: string, employeeIds?: Array<string>, customerId?: string, page?: string, workStatus?: Array<GetEstiamtesWorkStatusEnum>, pageSize?: number, sortDirection?: GetEstiamtesSortDirectionEnum, locationIds?: Array<string>, expand?: Array<GetEstiamtesExpandEnum>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetEstiamtes200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEstiamtes(scheduledStartMin, scheduledStartMax, scheduledEndMin, scheduledEndMax, employeeIds, customerId, page, workStatus, pageSize, sortDirection, locationIds, expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EstimatesApi.getEstiamtes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create an estimate
         * @summary Create an estimate
         * @param {EstimateCreate} [estimateCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postEstimates(estimateCreate?: EstimateCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Estimate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postEstimates(estimateCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EstimatesApi.postEstimates']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update an estimate option schedule.
         * @summary Update estimate option schedule
         * @param {string} estimateId 
         * @param {string} optionId 
         * @param {PutEstimatesEstimateIdOptionsOptionIdScheduleRequest} [putEstimatesEstimateIdOptionsOptionIdScheduleRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putEstimatesEstimateIdOptionsOptionIdSchedule(estimateId: string, optionId: string, putEstimatesEstimateIdOptionsOptionIdScheduleRequest?: PutEstimatesEstimateIdOptionsOptionIdScheduleRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PutEstimatesEstimateIdOptionsOptionIdSchedule200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putEstimatesEstimateIdOptionsOptionIdSchedule(estimateId, optionId, putEstimatesEstimateIdOptionsOptionIdScheduleRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EstimatesApi.putEstimatesEstimateIdOptionsOptionIdSchedule']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * EstimatesApi - factory interface
 * @export
 */
export const EstimatesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EstimatesApiFp(configuration)
    return {
        /**
         * Create a new estimate option attachment
         * @summary Create Estimate option attachment
         * @param {string} estimateId 
         * @param {string} optionId 
         * @param {File} file A binary file from your local machine
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEstimateOptionAttachment(estimateId: string, optionId: string, file: File, options?: RawAxiosRequestConfig): AxiosPromise<CreateEstimateOptionAttachment202Response> {
            return localVarFp.createEstimateOptionAttachment(estimateId, optionId, file, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new estimate option link
         * @summary Create Estimate option link
         * @param {string} estimateId 
         * @param {string} optionId 
         * @param {JobLinkCreate} [jobLinkCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEstimateOptionLink(estimateId: string, optionId: string, jobLinkCreate?: JobLinkCreate, options?: RawAxiosRequestConfig): AxiosPromise<JobLink> {
            return localVarFp.createEstimateOptionLink(estimateId, optionId, jobLinkCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new estimate option note
         * @summary Create Estimate option note
         * @param {string} estimateId 
         * @param {string} optionId 
         * @param {PostJobsJobIdNotesRequest} [postJobsJobIdNotesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEstimateOptionNote(estimateId: string, optionId: string, postJobsJobIdNotesRequest?: PostJobsJobIdNotesRequest, options?: RawAxiosRequestConfig): AxiosPromise<Note> {
            return localVarFp.createEstimateOptionNote(estimateId, optionId, postJobsJobIdNotesRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a specific estimate option note
         * @summary Delete estimate option note
         * @param {string} estimateId 
         * @param {string} optionId 
         * @param {string} noteId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEstimatesEstimateIdOptionsOptionIdNotes(estimateId: string, optionId: string, noteId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteEstimatesEstimateIdOptionsOptionIdNotes(estimateId, optionId, noteId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a single estimate by ID
         * @param {string} estimateId 
         * @param {Array<EstimatesEstimateIdGetExpandEnum>} [expand] Array of strings to expand response body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        estimatesEstimateIdGet(estimateId: string, expand?: Array<EstimatesEstimateIdGetExpandEnum>, options?: RawAxiosRequestConfig): AxiosPromise<Estimate> {
            return localVarFp.estimatesEstimateIdGet(estimateId, expand, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of estimates
         * @summary Get Estimates
         * @param {string} [scheduledStartMin] Filters estimates with a starting time greater than or equal to the date sent.
         * @param {string} [scheduledStartMax] Filters estimates with a starting time less than or equal to the date sent.
         * @param {string} [scheduledEndMin] Filters estimates with an end time greater than or equal to the date sent.
         * @param {string} [scheduledEndMax] Filters estimates with an end time less than or equal to the date sent.
         * @param {Array<string>} [employeeIds] Filters estimates by assigned pro id
         * @param {string} [customerId] Filters estimates by a single customer ID (string)
         * @param {string} [page] Paginated page number.
         * @param {Array<GetEstiamtesWorkStatusEnum>} [workStatus] Work status filter. Returns estimates from all statuses if empty.
         * @param {number} [pageSize] Number of estimates returned per page.
         * @param {GetEstiamtesSortDirectionEnum} [sortDirection] Order of estimates returned.
         * @param {Array<string>} [locationIds] Id of locations you want to pull from
         * @param {Array<GetEstiamtesExpandEnum>} [expand] Array of strings to expand response body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEstiamtes(scheduledStartMin?: string, scheduledStartMax?: string, scheduledEndMin?: string, scheduledEndMax?: string, employeeIds?: Array<string>, customerId?: string, page?: string, workStatus?: Array<GetEstiamtesWorkStatusEnum>, pageSize?: number, sortDirection?: GetEstiamtesSortDirectionEnum, locationIds?: Array<string>, expand?: Array<GetEstiamtesExpandEnum>, options?: RawAxiosRequestConfig): AxiosPromise<GetEstiamtes200Response> {
            return localVarFp.getEstiamtes(scheduledStartMin, scheduledStartMax, scheduledEndMin, scheduledEndMax, employeeIds, customerId, page, workStatus, pageSize, sortDirection, locationIds, expand, options).then((request) => request(axios, basePath));
        },
        /**
         * Create an estimate
         * @summary Create an estimate
         * @param {EstimateCreate} [estimateCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postEstimates(estimateCreate?: EstimateCreate, options?: RawAxiosRequestConfig): AxiosPromise<Estimate> {
            return localVarFp.postEstimates(estimateCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an estimate option schedule.
         * @summary Update estimate option schedule
         * @param {string} estimateId 
         * @param {string} optionId 
         * @param {PutEstimatesEstimateIdOptionsOptionIdScheduleRequest} [putEstimatesEstimateIdOptionsOptionIdScheduleRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putEstimatesEstimateIdOptionsOptionIdSchedule(estimateId: string, optionId: string, putEstimatesEstimateIdOptionsOptionIdScheduleRequest?: PutEstimatesEstimateIdOptionsOptionIdScheduleRequest, options?: RawAxiosRequestConfig): AxiosPromise<PutEstimatesEstimateIdOptionsOptionIdSchedule200Response> {
            return localVarFp.putEstimatesEstimateIdOptionsOptionIdSchedule(estimateId, optionId, putEstimatesEstimateIdOptionsOptionIdScheduleRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EstimatesApi - object-oriented interface
 * @export
 * @class EstimatesApi
 * @extends {BaseAPI}
 */
export class EstimatesApi extends BaseAPI {
    /**
     * Create a new estimate option attachment
     * @summary Create Estimate option attachment
     * @param {string} estimateId 
     * @param {string} optionId 
     * @param {File} file A binary file from your local machine
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EstimatesApi
     */
    public createEstimateOptionAttachment(estimateId: string, optionId: string, file: File, options?: RawAxiosRequestConfig) {
        return EstimatesApiFp(this.configuration).createEstimateOptionAttachment(estimateId, optionId, file, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new estimate option link
     * @summary Create Estimate option link
     * @param {string} estimateId 
     * @param {string} optionId 
     * @param {JobLinkCreate} [jobLinkCreate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EstimatesApi
     */
    public createEstimateOptionLink(estimateId: string, optionId: string, jobLinkCreate?: JobLinkCreate, options?: RawAxiosRequestConfig) {
        return EstimatesApiFp(this.configuration).createEstimateOptionLink(estimateId, optionId, jobLinkCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new estimate option note
     * @summary Create Estimate option note
     * @param {string} estimateId 
     * @param {string} optionId 
     * @param {PostJobsJobIdNotesRequest} [postJobsJobIdNotesRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EstimatesApi
     */
    public createEstimateOptionNote(estimateId: string, optionId: string, postJobsJobIdNotesRequest?: PostJobsJobIdNotesRequest, options?: RawAxiosRequestConfig) {
        return EstimatesApiFp(this.configuration).createEstimateOptionNote(estimateId, optionId, postJobsJobIdNotesRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a specific estimate option note
     * @summary Delete estimate option note
     * @param {string} estimateId 
     * @param {string} optionId 
     * @param {string} noteId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EstimatesApi
     */
    public deleteEstimatesEstimateIdOptionsOptionIdNotes(estimateId: string, optionId: string, noteId: string, options?: RawAxiosRequestConfig) {
        return EstimatesApiFp(this.configuration).deleteEstimatesEstimateIdOptionsOptionIdNotes(estimateId, optionId, noteId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a single estimate by ID
     * @param {string} estimateId 
     * @param {Array<EstimatesEstimateIdGetExpandEnum>} [expand] Array of strings to expand response body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EstimatesApi
     */
    public estimatesEstimateIdGet(estimateId: string, expand?: Array<EstimatesEstimateIdGetExpandEnum>, options?: RawAxiosRequestConfig) {
        return EstimatesApiFp(this.configuration).estimatesEstimateIdGet(estimateId, expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of estimates
     * @summary Get Estimates
     * @param {string} [scheduledStartMin] Filters estimates with a starting time greater than or equal to the date sent.
     * @param {string} [scheduledStartMax] Filters estimates with a starting time less than or equal to the date sent.
     * @param {string} [scheduledEndMin] Filters estimates with an end time greater than or equal to the date sent.
     * @param {string} [scheduledEndMax] Filters estimates with an end time less than or equal to the date sent.
     * @param {Array<string>} [employeeIds] Filters estimates by assigned pro id
     * @param {string} [customerId] Filters estimates by a single customer ID (string)
     * @param {string} [page] Paginated page number.
     * @param {Array<GetEstiamtesWorkStatusEnum>} [workStatus] Work status filter. Returns estimates from all statuses if empty.
     * @param {number} [pageSize] Number of estimates returned per page.
     * @param {GetEstiamtesSortDirectionEnum} [sortDirection] Order of estimates returned.
     * @param {Array<string>} [locationIds] Id of locations you want to pull from
     * @param {Array<GetEstiamtesExpandEnum>} [expand] Array of strings to expand response body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EstimatesApi
     */
    public getEstiamtes(scheduledStartMin?: string, scheduledStartMax?: string, scheduledEndMin?: string, scheduledEndMax?: string, employeeIds?: Array<string>, customerId?: string, page?: string, workStatus?: Array<GetEstiamtesWorkStatusEnum>, pageSize?: number, sortDirection?: GetEstiamtesSortDirectionEnum, locationIds?: Array<string>, expand?: Array<GetEstiamtesExpandEnum>, options?: RawAxiosRequestConfig) {
        return EstimatesApiFp(this.configuration).getEstiamtes(scheduledStartMin, scheduledStartMax, scheduledEndMin, scheduledEndMax, employeeIds, customerId, page, workStatus, pageSize, sortDirection, locationIds, expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create an estimate
     * @summary Create an estimate
     * @param {EstimateCreate} [estimateCreate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EstimatesApi
     */
    public postEstimates(estimateCreate?: EstimateCreate, options?: RawAxiosRequestConfig) {
        return EstimatesApiFp(this.configuration).postEstimates(estimateCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an estimate option schedule.
     * @summary Update estimate option schedule
     * @param {string} estimateId 
     * @param {string} optionId 
     * @param {PutEstimatesEstimateIdOptionsOptionIdScheduleRequest} [putEstimatesEstimateIdOptionsOptionIdScheduleRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EstimatesApi
     */
    public putEstimatesEstimateIdOptionsOptionIdSchedule(estimateId: string, optionId: string, putEstimatesEstimateIdOptionsOptionIdScheduleRequest?: PutEstimatesEstimateIdOptionsOptionIdScheduleRequest, options?: RawAxiosRequestConfig) {
        return EstimatesApiFp(this.configuration).putEstimatesEstimateIdOptionsOptionIdSchedule(estimateId, optionId, putEstimatesEstimateIdOptionsOptionIdScheduleRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const EstimatesEstimateIdGetExpandEnum = {
    Attachments: 'attachments'
} as const;
export type EstimatesEstimateIdGetExpandEnum = typeof EstimatesEstimateIdGetExpandEnum[keyof typeof EstimatesEstimateIdGetExpandEnum];
/**
 * @export
 */
export const GetEstiamtesWorkStatusEnum = {
    Unscheduled: 'unscheduled',
    Scheduled: 'scheduled',
    InProgress: 'in_progress',
    Completed: 'completed',
    Canceled: 'canceled'
} as const;
export type GetEstiamtesWorkStatusEnum = typeof GetEstiamtesWorkStatusEnum[keyof typeof GetEstiamtesWorkStatusEnum];
/**
 * @export
 */
export const GetEstiamtesSortDirectionEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type GetEstiamtesSortDirectionEnum = typeof GetEstiamtesSortDirectionEnum[keyof typeof GetEstiamtesSortDirectionEnum];
/**
 * @export
 */
export const GetEstiamtesExpandEnum = {
    Attachments: 'attachments'
} as const;
export type GetEstiamtesExpandEnum = typeof GetEstiamtesExpandEnum[keyof typeof GetEstiamtesExpandEnum];


/**
 * EventsApi - axios parameter creator
 * @export
 */
export const EventsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get a list of events
         * @summary Get Events
         * @param {number} [page] Paginated page number
         * @param {number} [pageSize] Number of events returned per page.
         * @param {GetEventsSortByEnum} [sortBy] Event attribute to sort by
         * @param {GetEventsSortDirectionEnum} [sortDirection] Ascending or descending
         * @param {Array<string>} [locationIds] Id of locations you want to pull from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEvents: async (page?: number, pageSize?: number, sortBy?: GetEventsSortByEnum, sortDirection?: GetEventsSortDirectionEnum, locationIds?: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/events`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApplicationAPIKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication CompanyAPIKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication HousecallUserOAuthToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "HousecallUserOAuthToken", [], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (sortDirection !== undefined) {
                localVarQueryParameter['sort_direction'] = sortDirection;
            }

            if (locationIds) {
                localVarQueryParameter['location_ids'] = locationIds;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the event via ID.
         * @summary Get the event via ID.
         * @param {string} eventId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventsEventId: async (eventId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('getEventsEventId', 'eventId', eventId)
            const localVarPath = `/events/{event_id}`
                .replace(`{${"event_id"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApplicationAPIKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication CompanyAPIKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication HousecallUserOAuthToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "HousecallUserOAuthToken", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EventsApi - functional programming interface
 * @export
 */
export const EventsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EventsApiAxiosParamCreator(configuration)
    return {
        /**
         * Get a list of events
         * @summary Get Events
         * @param {number} [page] Paginated page number
         * @param {number} [pageSize] Number of events returned per page.
         * @param {GetEventsSortByEnum} [sortBy] Event attribute to sort by
         * @param {GetEventsSortDirectionEnum} [sortDirection] Ascending or descending
         * @param {Array<string>} [locationIds] Id of locations you want to pull from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEvents(page?: number, pageSize?: number, sortBy?: GetEventsSortByEnum, sortDirection?: GetEventsSortDirectionEnum, locationIds?: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetEvents200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEvents(page, pageSize, sortBy, sortDirection, locationIds, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EventsApi.getEvents']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the event via ID.
         * @summary Get the event via ID.
         * @param {string} eventId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEventsEventId(eventId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Event>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEventsEventId(eventId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EventsApi.getEventsEventId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * EventsApi - factory interface
 * @export
 */
export const EventsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EventsApiFp(configuration)
    return {
        /**
         * Get a list of events
         * @summary Get Events
         * @param {number} [page] Paginated page number
         * @param {number} [pageSize] Number of events returned per page.
         * @param {GetEventsSortByEnum} [sortBy] Event attribute to sort by
         * @param {GetEventsSortDirectionEnum} [sortDirection] Ascending or descending
         * @param {Array<string>} [locationIds] Id of locations you want to pull from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEvents(page?: number, pageSize?: number, sortBy?: GetEventsSortByEnum, sortDirection?: GetEventsSortDirectionEnum, locationIds?: Array<string>, options?: RawAxiosRequestConfig): AxiosPromise<GetEvents200Response> {
            return localVarFp.getEvents(page, pageSize, sortBy, sortDirection, locationIds, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the event via ID.
         * @summary Get the event via ID.
         * @param {string} eventId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventsEventId(eventId: string, options?: RawAxiosRequestConfig): AxiosPromise<Event> {
            return localVarFp.getEventsEventId(eventId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EventsApi - object-oriented interface
 * @export
 * @class EventsApi
 * @extends {BaseAPI}
 */
export class EventsApi extends BaseAPI {
    /**
     * Get a list of events
     * @summary Get Events
     * @param {number} [page] Paginated page number
     * @param {number} [pageSize] Number of events returned per page.
     * @param {GetEventsSortByEnum} [sortBy] Event attribute to sort by
     * @param {GetEventsSortDirectionEnum} [sortDirection] Ascending or descending
     * @param {Array<string>} [locationIds] Id of locations you want to pull from
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public getEvents(page?: number, pageSize?: number, sortBy?: GetEventsSortByEnum, sortDirection?: GetEventsSortDirectionEnum, locationIds?: Array<string>, options?: RawAxiosRequestConfig) {
        return EventsApiFp(this.configuration).getEvents(page, pageSize, sortBy, sortDirection, locationIds, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the event via ID.
     * @summary Get the event via ID.
     * @param {string} eventId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public getEventsEventId(eventId: string, options?: RawAxiosRequestConfig) {
        return EventsApiFp(this.configuration).getEventsEventId(eventId, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const GetEventsSortByEnum = {
    Name: 'name',
    Note: 'note',
    CreatedAt: 'created_at',
    UpdatedAt: 'updated_at',
    Street: 'street',
    StreetLine2: 'street_line_2',
    City: 'city',
    State: 'state',
    Zip: 'zip'
} as const;
export type GetEventsSortByEnum = typeof GetEventsSortByEnum[keyof typeof GetEventsSortByEnum];
/**
 * @export
 */
export const GetEventsSortDirectionEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type GetEventsSortDirectionEnum = typeof GetEventsSortDirectionEnum[keyof typeof GetEventsSortDirectionEnum];


/**
 * InvoicesApi - axios parameter creator
 * @export
 */
export const InvoicesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get a list of invoices. Note: Organization must have configured progressive invoicing
         * @summary Get Invoices
         * @param {Array<string>} [locationIds] Id of locations you want to pull from
         * @param {Array<GetInvoicesStatusEnum>} [status] Filters invoices by status.
         * @param {string} [createdAtMin] Filters invoices with a created_at greater than or equal to the input date
         * @param {string} [createdAtMax] Filters invoices with a created_at less than or equal to the input date
         * @param {string} [dueAtMin] Filters invoices with a due_at greater than or equal to the input date
         * @param {string} [dueAtMax] Filters invoices with a due_at less than or equal to the input date
         * @param {string} [paidAtMin] Filters invoices with a paid_at greater than or equal to the input date
         * @param {string} [paidAtMax] Filters invoices with a paid_at less than or equal to the input date
         * @param {number} [amountDueMin] Filters invoices with an amount_due greater than or equal to the input amount
         * @param {number} [amountDueMax] Filters invoices with an amount_due less than or equal to the input amount
         * @param {Array<GetInvoicesPaymentMethodEnum>} [paymentMethod] Filters invoices by payment_method.
         * @param {number} [page] Paginated page number.
         * @param {string} [pageSize] Number of invoices returned per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoices: async (locationIds?: Array<string>, status?: Array<GetInvoicesStatusEnum>, createdAtMin?: string, createdAtMax?: string, dueAtMin?: string, dueAtMax?: string, paidAtMin?: string, paidAtMax?: string, amountDueMin?: number, amountDueMax?: number, paymentMethod?: Array<GetInvoicesPaymentMethodEnum>, page?: number, pageSize?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/invoices`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApplicationAPIKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication CompanyAPIKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication HousecallUserOAuthToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "HousecallUserOAuthToken", [], configuration)

            if (locationIds) {
                localVarQueryParameter['location_ids'] = locationIds;
            }

            if (status) {
                localVarQueryParameter['status'] = status;
            }

            if (createdAtMin !== undefined) {
                localVarQueryParameter['created_at_min'] = createdAtMin;
            }

            if (createdAtMax !== undefined) {
                localVarQueryParameter['created_at_max'] = createdAtMax;
            }

            if (dueAtMin !== undefined) {
                localVarQueryParameter['due_at_min'] = dueAtMin;
            }

            if (dueAtMax !== undefined) {
                localVarQueryParameter['due_at_max'] = dueAtMax;
            }

            if (paidAtMin !== undefined) {
                localVarQueryParameter['paid_at_min'] = paidAtMin;
            }

            if (paidAtMax !== undefined) {
                localVarQueryParameter['paid_at_max'] = paidAtMax;
            }

            if (amountDueMin !== undefined) {
                localVarQueryParameter['amount_due_min'] = amountDueMin;
            }

            if (amountDueMax !== undefined) {
                localVarQueryParameter['amount_due_max'] = amountDueMax;
            }

            if (paymentMethod) {
                localVarQueryParameter['payment_method'] = paymentMethod;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InvoicesApi - functional programming interface
 * @export
 */
export const InvoicesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = InvoicesApiAxiosParamCreator(configuration)
    return {
        /**
         * Get a list of invoices. Note: Organization must have configured progressive invoicing
         * @summary Get Invoices
         * @param {Array<string>} [locationIds] Id of locations you want to pull from
         * @param {Array<GetInvoicesStatusEnum>} [status] Filters invoices by status.
         * @param {string} [createdAtMin] Filters invoices with a created_at greater than or equal to the input date
         * @param {string} [createdAtMax] Filters invoices with a created_at less than or equal to the input date
         * @param {string} [dueAtMin] Filters invoices with a due_at greater than or equal to the input date
         * @param {string} [dueAtMax] Filters invoices with a due_at less than or equal to the input date
         * @param {string} [paidAtMin] Filters invoices with a paid_at greater than or equal to the input date
         * @param {string} [paidAtMax] Filters invoices with a paid_at less than or equal to the input date
         * @param {number} [amountDueMin] Filters invoices with an amount_due greater than or equal to the input amount
         * @param {number} [amountDueMax] Filters invoices with an amount_due less than or equal to the input amount
         * @param {Array<GetInvoicesPaymentMethodEnum>} [paymentMethod] Filters invoices by payment_method.
         * @param {number} [page] Paginated page number.
         * @param {string} [pageSize] Number of invoices returned per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInvoices(locationIds?: Array<string>, status?: Array<GetInvoicesStatusEnum>, createdAtMin?: string, createdAtMax?: string, dueAtMin?: string, dueAtMax?: string, paidAtMin?: string, paidAtMax?: string, amountDueMin?: number, amountDueMax?: number, paymentMethod?: Array<GetInvoicesPaymentMethodEnum>, page?: number, pageSize?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetInvoices200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInvoices(locationIds, status, createdAtMin, createdAtMax, dueAtMin, dueAtMax, paidAtMin, paidAtMax, amountDueMin, amountDueMax, paymentMethod, page, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InvoicesApi.getInvoices']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * InvoicesApi - factory interface
 * @export
 */
export const InvoicesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = InvoicesApiFp(configuration)
    return {
        /**
         * Get a list of invoices. Note: Organization must have configured progressive invoicing
         * @summary Get Invoices
         * @param {Array<string>} [locationIds] Id of locations you want to pull from
         * @param {Array<GetInvoicesStatusEnum>} [status] Filters invoices by status.
         * @param {string} [createdAtMin] Filters invoices with a created_at greater than or equal to the input date
         * @param {string} [createdAtMax] Filters invoices with a created_at less than or equal to the input date
         * @param {string} [dueAtMin] Filters invoices with a due_at greater than or equal to the input date
         * @param {string} [dueAtMax] Filters invoices with a due_at less than or equal to the input date
         * @param {string} [paidAtMin] Filters invoices with a paid_at greater than or equal to the input date
         * @param {string} [paidAtMax] Filters invoices with a paid_at less than or equal to the input date
         * @param {number} [amountDueMin] Filters invoices with an amount_due greater than or equal to the input amount
         * @param {number} [amountDueMax] Filters invoices with an amount_due less than or equal to the input amount
         * @param {Array<GetInvoicesPaymentMethodEnum>} [paymentMethod] Filters invoices by payment_method.
         * @param {number} [page] Paginated page number.
         * @param {string} [pageSize] Number of invoices returned per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoices(locationIds?: Array<string>, status?: Array<GetInvoicesStatusEnum>, createdAtMin?: string, createdAtMax?: string, dueAtMin?: string, dueAtMax?: string, paidAtMin?: string, paidAtMax?: string, amountDueMin?: number, amountDueMax?: number, paymentMethod?: Array<GetInvoicesPaymentMethodEnum>, page?: number, pageSize?: string, options?: RawAxiosRequestConfig): AxiosPromise<GetInvoices200Response> {
            return localVarFp.getInvoices(locationIds, status, createdAtMin, createdAtMax, dueAtMin, dueAtMax, paidAtMin, paidAtMax, amountDueMin, amountDueMax, paymentMethod, page, pageSize, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * InvoicesApi - object-oriented interface
 * @export
 * @class InvoicesApi
 * @extends {BaseAPI}
 */
export class InvoicesApi extends BaseAPI {
    /**
     * Get a list of invoices. Note: Organization must have configured progressive invoicing
     * @summary Get Invoices
     * @param {Array<string>} [locationIds] Id of locations you want to pull from
     * @param {Array<GetInvoicesStatusEnum>} [status] Filters invoices by status.
     * @param {string} [createdAtMin] Filters invoices with a created_at greater than or equal to the input date
     * @param {string} [createdAtMax] Filters invoices with a created_at less than or equal to the input date
     * @param {string} [dueAtMin] Filters invoices with a due_at greater than or equal to the input date
     * @param {string} [dueAtMax] Filters invoices with a due_at less than or equal to the input date
     * @param {string} [paidAtMin] Filters invoices with a paid_at greater than or equal to the input date
     * @param {string} [paidAtMax] Filters invoices with a paid_at less than or equal to the input date
     * @param {number} [amountDueMin] Filters invoices with an amount_due greater than or equal to the input amount
     * @param {number} [amountDueMax] Filters invoices with an amount_due less than or equal to the input amount
     * @param {Array<GetInvoicesPaymentMethodEnum>} [paymentMethod] Filters invoices by payment_method.
     * @param {number} [page] Paginated page number.
     * @param {string} [pageSize] Number of invoices returned per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicesApi
     */
    public getInvoices(locationIds?: Array<string>, status?: Array<GetInvoicesStatusEnum>, createdAtMin?: string, createdAtMax?: string, dueAtMin?: string, dueAtMax?: string, paidAtMin?: string, paidAtMax?: string, amountDueMin?: number, amountDueMax?: number, paymentMethod?: Array<GetInvoicesPaymentMethodEnum>, page?: number, pageSize?: string, options?: RawAxiosRequestConfig) {
        return InvoicesApiFp(this.configuration).getInvoices(locationIds, status, createdAtMin, createdAtMax, dueAtMin, dueAtMax, paidAtMin, paidAtMax, amountDueMin, amountDueMax, paymentMethod, page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const GetInvoicesStatusEnum = {
    Open: 'open',
    PendingPayment: 'pending_payment',
    Paid: 'paid',
    Voided: 'voided',
    Uncollectible: 'uncollectible',
    Canceled: 'canceled'
} as const;
export type GetInvoicesStatusEnum = typeof GetInvoicesStatusEnum[keyof typeof GetInvoicesStatusEnum];
/**
 * @export
 */
export const GetInvoicesPaymentMethodEnum = {
    ConsumerFinancing: 'consumer_financing',
    CreditCard: 'credit_card',
    Ach: 'ach',
    External: 'external',
    MobileCheckDeposit: 'mobile_check_deposit'
} as const;
export type GetInvoicesPaymentMethodEnum = typeof GetInvoicesPaymentMethodEnum[keyof typeof GetInvoicesPaymentMethodEnum];


/**
 * JobAppointmentsApi - axios parameter creator
 * @export
 */
export const JobAppointmentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete a job appointment.
         * @summary Delete appointment
         * @param {string} jobId 
         * @param {string} appointmentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteJobsJobIdAppointments: async (jobId: string, appointmentId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('deleteJobsJobIdAppointments', 'jobId', jobId)
            // verify required parameter 'appointmentId' is not null or undefined
            assertParamExists('deleteJobsJobIdAppointments', 'appointmentId', appointmentId)
            const localVarPath = `/jobs/{job_id}/appointments/{appointment_id}`
                .replace(`{${"job_id"}}`, encodeURIComponent(String(jobId)))
                .replace(`{${"appointment_id"}}`, encodeURIComponent(String(appointmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CompanyAPIKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication HousecallUserOAuthToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "HousecallUserOAuthToken", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all of the appointments for a job
         * @summary Get Appointments
         * @param {string} jobId 
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobsJobIdAppointments: async (jobId: string, body?: object, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('getJobsJobIdAppointments', 'jobId', jobId)
            const localVarPath = `/jobs/{job_id}/appointments`
                .replace(`{${"job_id"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CompanyAPIKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication HousecallUserOAuthToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "HousecallUserOAuthToken", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add an appointment to a job.
         * @summary Create appointment
         * @param {string} jobId 
         * @param {CreateAppointment} [createAppointment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postJobsJobIdAppointments: async (jobId: string, createAppointment?: CreateAppointment, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('postJobsJobIdAppointments', 'jobId', jobId)
            const localVarPath = `/jobs/{job_id}/appointments`
                .replace(`{${"job_id"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CompanyAPIKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication HousecallUserOAuthToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "HousecallUserOAuthToken", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createAppointment, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update job appointment
         * @summary Update Appointment
         * @param {string} jobId 
         * @param {string} appointmentId 
         * @param {CreateAppointment} [createAppointment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateJobsJobIdAppointments: async (jobId: string, appointmentId: string, createAppointment?: CreateAppointment, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('updateJobsJobIdAppointments', 'jobId', jobId)
            // verify required parameter 'appointmentId' is not null or undefined
            assertParamExists('updateJobsJobIdAppointments', 'appointmentId', appointmentId)
            const localVarPath = `/jobs/{job_id}/appointments/{appointment_id}`
                .replace(`{${"job_id"}}`, encodeURIComponent(String(jobId)))
                .replace(`{${"appointment_id"}}`, encodeURIComponent(String(appointmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CompanyAPIKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication HousecallUserOAuthToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "HousecallUserOAuthToken", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createAppointment, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * JobAppointmentsApi - functional programming interface
 * @export
 */
export const JobAppointmentsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = JobAppointmentsApiAxiosParamCreator(configuration)
    return {
        /**
         * Delete a job appointment.
         * @summary Delete appointment
         * @param {string} jobId 
         * @param {string} appointmentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteJobsJobIdAppointments(jobId: string, appointmentId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteJobsJobIdAppointments(jobId, appointmentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['JobAppointmentsApi.deleteJobsJobIdAppointments']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all of the appointments for a job
         * @summary Get Appointments
         * @param {string} jobId 
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getJobsJobIdAppointments(jobId: string, body?: object, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetJobsJobIdAppointments200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getJobsJobIdAppointments(jobId, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['JobAppointmentsApi.getJobsJobIdAppointments']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Add an appointment to a job.
         * @summary Create appointment
         * @param {string} jobId 
         * @param {CreateAppointment} [createAppointment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postJobsJobIdAppointments(jobId: string, createAppointment?: CreateAppointment, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Appointment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postJobsJobIdAppointments(jobId, createAppointment, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['JobAppointmentsApi.postJobsJobIdAppointments']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update job appointment
         * @summary Update Appointment
         * @param {string} jobId 
         * @param {string} appointmentId 
         * @param {CreateAppointment} [createAppointment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateJobsJobIdAppointments(jobId: string, appointmentId: string, createAppointment?: CreateAppointment, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Appointment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateJobsJobIdAppointments(jobId, appointmentId, createAppointment, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['JobAppointmentsApi.updateJobsJobIdAppointments']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * JobAppointmentsApi - factory interface
 * @export
 */
export const JobAppointmentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = JobAppointmentsApiFp(configuration)
    return {
        /**
         * Delete a job appointment.
         * @summary Delete appointment
         * @param {string} jobId 
         * @param {string} appointmentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteJobsJobIdAppointments(jobId: string, appointmentId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteJobsJobIdAppointments(jobId, appointmentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all of the appointments for a job
         * @summary Get Appointments
         * @param {string} jobId 
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobsJobIdAppointments(jobId: string, body?: object, options?: RawAxiosRequestConfig): AxiosPromise<GetJobsJobIdAppointments200Response> {
            return localVarFp.getJobsJobIdAppointments(jobId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Add an appointment to a job.
         * @summary Create appointment
         * @param {string} jobId 
         * @param {CreateAppointment} [createAppointment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postJobsJobIdAppointments(jobId: string, createAppointment?: CreateAppointment, options?: RawAxiosRequestConfig): AxiosPromise<Appointment> {
            return localVarFp.postJobsJobIdAppointments(jobId, createAppointment, options).then((request) => request(axios, basePath));
        },
        /**
         * Update job appointment
         * @summary Update Appointment
         * @param {string} jobId 
         * @param {string} appointmentId 
         * @param {CreateAppointment} [createAppointment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateJobsJobIdAppointments(jobId: string, appointmentId: string, createAppointment?: CreateAppointment, options?: RawAxiosRequestConfig): AxiosPromise<Appointment> {
            return localVarFp.updateJobsJobIdAppointments(jobId, appointmentId, createAppointment, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * JobAppointmentsApi - object-oriented interface
 * @export
 * @class JobAppointmentsApi
 * @extends {BaseAPI}
 */
export class JobAppointmentsApi extends BaseAPI {
    /**
     * Delete a job appointment.
     * @summary Delete appointment
     * @param {string} jobId 
     * @param {string} appointmentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobAppointmentsApi
     */
    public deleteJobsJobIdAppointments(jobId: string, appointmentId: string, options?: RawAxiosRequestConfig) {
        return JobAppointmentsApiFp(this.configuration).deleteJobsJobIdAppointments(jobId, appointmentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all of the appointments for a job
     * @summary Get Appointments
     * @param {string} jobId 
     * @param {object} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobAppointmentsApi
     */
    public getJobsJobIdAppointments(jobId: string, body?: object, options?: RawAxiosRequestConfig) {
        return JobAppointmentsApiFp(this.configuration).getJobsJobIdAppointments(jobId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add an appointment to a job.
     * @summary Create appointment
     * @param {string} jobId 
     * @param {CreateAppointment} [createAppointment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobAppointmentsApi
     */
    public postJobsJobIdAppointments(jobId: string, createAppointment?: CreateAppointment, options?: RawAxiosRequestConfig) {
        return JobAppointmentsApiFp(this.configuration).postJobsJobIdAppointments(jobId, createAppointment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update job appointment
     * @summary Update Appointment
     * @param {string} jobId 
     * @param {string} appointmentId 
     * @param {CreateAppointment} [createAppointment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobAppointmentsApi
     */
    public updateJobsJobIdAppointments(jobId: string, appointmentId: string, createAppointment?: CreateAppointment, options?: RawAxiosRequestConfig) {
        return JobAppointmentsApiFp(this.configuration).updateJobsJobIdAppointments(jobId, appointmentId, createAppointment, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * JobInvoicesApi - axios parameter creator
 * @export
 */
export const JobInvoicesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Lists all invoices for a job. Note: Organization must have configured progressive invoicing
         * @summary Get Job Invoices
         * @param {string} jobId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobsJobIdInvoices: async (jobId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('getJobsJobIdInvoices', 'jobId', jobId)
            const localVarPath = `/jobs/{job_id}/invoices`
                .replace(`{${"job_id"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * JobInvoicesApi - functional programming interface
 * @export
 */
export const JobInvoicesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = JobInvoicesApiAxiosParamCreator(configuration)
    return {
        /**
         * Lists all invoices for a job. Note: Organization must have configured progressive invoicing
         * @summary Get Job Invoices
         * @param {string} jobId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getJobsJobIdInvoices(jobId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetJobsJobIdInvoices200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getJobsJobIdInvoices(jobId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['JobInvoicesApi.getJobsJobIdInvoices']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * JobInvoicesApi - factory interface
 * @export
 */
export const JobInvoicesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = JobInvoicesApiFp(configuration)
    return {
        /**
         * Lists all invoices for a job. Note: Organization must have configured progressive invoicing
         * @summary Get Job Invoices
         * @param {string} jobId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobsJobIdInvoices(jobId: string, options?: RawAxiosRequestConfig): AxiosPromise<GetJobsJobIdInvoices200Response> {
            return localVarFp.getJobsJobIdInvoices(jobId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * JobInvoicesApi - object-oriented interface
 * @export
 * @class JobInvoicesApi
 * @extends {BaseAPI}
 */
export class JobInvoicesApi extends BaseAPI {
    /**
     * Lists all invoices for a job. Note: Organization must have configured progressive invoicing
     * @summary Get Job Invoices
     * @param {string} jobId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobInvoicesApi
     */
    public getJobsJobIdInvoices(jobId: string, options?: RawAxiosRequestConfig) {
        return JobInvoicesApiFp(this.configuration).getJobsJobIdInvoices(jobId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * JobTypesApi - axios parameter creator
 * @export
 */
export const JobTypesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get a list of job types
         * @summary Get Job Types
         * @param {string} [name] filter job types by name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobFieldsJobTypes: async (name?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/job_fields/job_types`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CompanyAPIKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication HousecallUserOAuthToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "HousecallUserOAuthToken", [], configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * create a job type
         * @summary Create Job Type
         * @param {PostLeadSourcesRequest} [postLeadSourcesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postJobFieldsJobTypes: async (postLeadSourcesRequest?: PostLeadSourcesRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/job_fields/job_types`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CompanyAPIKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication HousecallUserOAuthToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "HousecallUserOAuthToken", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postLeadSourcesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a job type
         * @summary Update a Job Type
         * @param {string} jobTypeId 
         * @param {PostLeadSourcesRequest} [postLeadSourcesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putJobFieldsJobTypes: async (jobTypeId: string, postLeadSourcesRequest?: PostLeadSourcesRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobTypeId' is not null or undefined
            assertParamExists('putJobFieldsJobTypes', 'jobTypeId', jobTypeId)
            const localVarPath = `/job_fields/job_types/{job_type_id}`
                .replace(`{${"job_type_id"}}`, encodeURIComponent(String(jobTypeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CompanyAPIKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication HousecallUserOAuthToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "HousecallUserOAuthToken", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postLeadSourcesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * JobTypesApi - functional programming interface
 * @export
 */
export const JobTypesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = JobTypesApiAxiosParamCreator(configuration)
    return {
        /**
         * Get a list of job types
         * @summary Get Job Types
         * @param {string} [name] filter job types by name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getJobFieldsJobTypes(name?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetJobFieldsJobTypes200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getJobFieldsJobTypes(name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['JobTypesApi.getJobFieldsJobTypes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * create a job type
         * @summary Create Job Type
         * @param {PostLeadSourcesRequest} [postLeadSourcesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postJobFieldsJobTypes(postLeadSourcesRequest?: PostLeadSourcesRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JobType>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postJobFieldsJobTypes(postLeadSourcesRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['JobTypesApi.postJobFieldsJobTypes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update a job type
         * @summary Update a Job Type
         * @param {string} jobTypeId 
         * @param {PostLeadSourcesRequest} [postLeadSourcesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putJobFieldsJobTypes(jobTypeId: string, postLeadSourcesRequest?: PostLeadSourcesRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JobType>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putJobFieldsJobTypes(jobTypeId, postLeadSourcesRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['JobTypesApi.putJobFieldsJobTypes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * JobTypesApi - factory interface
 * @export
 */
export const JobTypesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = JobTypesApiFp(configuration)
    return {
        /**
         * Get a list of job types
         * @summary Get Job Types
         * @param {string} [name] filter job types by name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobFieldsJobTypes(name?: string, options?: RawAxiosRequestConfig): AxiosPromise<GetJobFieldsJobTypes200Response> {
            return localVarFp.getJobFieldsJobTypes(name, options).then((request) => request(axios, basePath));
        },
        /**
         * create a job type
         * @summary Create Job Type
         * @param {PostLeadSourcesRequest} [postLeadSourcesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postJobFieldsJobTypes(postLeadSourcesRequest?: PostLeadSourcesRequest, options?: RawAxiosRequestConfig): AxiosPromise<JobType> {
            return localVarFp.postJobFieldsJobTypes(postLeadSourcesRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a job type
         * @summary Update a Job Type
         * @param {string} jobTypeId 
         * @param {PostLeadSourcesRequest} [postLeadSourcesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putJobFieldsJobTypes(jobTypeId: string, postLeadSourcesRequest?: PostLeadSourcesRequest, options?: RawAxiosRequestConfig): AxiosPromise<JobType> {
            return localVarFp.putJobFieldsJobTypes(jobTypeId, postLeadSourcesRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * JobTypesApi - object-oriented interface
 * @export
 * @class JobTypesApi
 * @extends {BaseAPI}
 */
export class JobTypesApi extends BaseAPI {
    /**
     * Get a list of job types
     * @summary Get Job Types
     * @param {string} [name] filter job types by name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobTypesApi
     */
    public getJobFieldsJobTypes(name?: string, options?: RawAxiosRequestConfig) {
        return JobTypesApiFp(this.configuration).getJobFieldsJobTypes(name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * create a job type
     * @summary Create Job Type
     * @param {PostLeadSourcesRequest} [postLeadSourcesRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobTypesApi
     */
    public postJobFieldsJobTypes(postLeadSourcesRequest?: PostLeadSourcesRequest, options?: RawAxiosRequestConfig) {
        return JobTypesApiFp(this.configuration).postJobFieldsJobTypes(postLeadSourcesRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a job type
     * @summary Update a Job Type
     * @param {string} jobTypeId 
     * @param {PostLeadSourcesRequest} [postLeadSourcesRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobTypesApi
     */
    public putJobFieldsJobTypes(jobTypeId: string, postLeadSourcesRequest?: PostLeadSourcesRequest, options?: RawAxiosRequestConfig) {
        return JobTypesApiFp(this.configuration).putJobFieldsJobTypes(jobTypeId, postLeadSourcesRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * JobsApi - axios parameter creator
 * @export
 */
export const JobsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new Job link
         * @summary Create Job Link
         * @param {string} jobId 
         * @param {JobLinkCreate} [jobLinkCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createJobLink: async (jobId: string, jobLinkCreate?: JobLinkCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('createJobLink', 'jobId', jobId)
            const localVarPath = `/jobs/{job_id}/links`
                .replace(`{${"job_id"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApplicationAPIKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication HousecallUserOAuthToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "HousecallUserOAuthToken", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(jobLinkCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a single line item for a job
         * @param {string} jobId 
         * @param {string} id 
         * @param {LineItem} [lineItem] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteJobLineItem: async (jobId: string, id: string, lineItem?: LineItem, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('deleteJobLineItem', 'jobId', jobId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteJobLineItem', 'id', id)
            const localVarPath = `/jobs/{job_id}/line_items/{id}`
                .replace(`{${"job_id"}}`, encodeURIComponent(String(jobId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(lineItem, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Erase schedule on a job
         * @summary Delete job schedule
         * @param {string} jobId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteJobSchedule: async (jobId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('deleteJobSchedule', 'jobId', jobId)
            const localVarPath = `/jobs/{job_id}/schedule`
                .replace(`{${"job_id"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApplicationAPIKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication HousecallUserOAuthToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "HousecallUserOAuthToken", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a specific job note
         * @summary Delete job note
         * @param {string} jobId 
         * @param {string} noteId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteJobsJobIdNotes: async (jobId: string, noteId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('deleteJobsJobIdNotes', 'jobId', jobId)
            // verify required parameter 'noteId' is not null or undefined
            assertParamExists('deleteJobsJobIdNotes', 'noteId', noteId)
            const localVarPath = `/jobs/{job_id}/notes/{note_id}`
                .replace(`{${"job_id"}}`, encodeURIComponent(String(jobId)))
                .replace(`{${"note_id"}}`, encodeURIComponent(String(noteId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApplicationAPIKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication CompanyAPIKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication HousecallUserOAuthToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "HousecallUserOAuthToken", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove a tag from a job
         * @summary Remove job tag
         * @param {string} jobId 
         * @param {string} tagId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteJobsJobIdTagsTagId: async (jobId: string, tagId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('deleteJobsJobIdTagsTagId', 'jobId', jobId)
            // verify required parameter 'tagId' is not null or undefined
            assertParamExists('deleteJobsJobIdTagsTagId', 'tagId', tagId)
            const localVarPath = `/jobs/{job_id}/tags/{tag_id}`
                .replace(`{${"job_id"}}`, encodeURIComponent(String(jobId)))
                .replace(`{${"tag_id"}}`, encodeURIComponent(String(tagId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApplicationAPIKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication CompanyAPIKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication HousecallUserOAuthToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "HousecallUserOAuthToken", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of jobs
         * @summary Get Jobs
         * @param {string} [scheduledStartMin] Filters jobs with a starting time greater than or equal to the date sent.
         * @param {string} [scheduledStartMax] Filters jobs with a starting time less than or equal to the date sent.
         * @param {string} [scheduledEndMin] Filters jobs with an end time greater than or equal to the date  sent.
         * @param {string} [scheduledEndMax] Filters jobs with an end time less than or equal to the date sent.
         * @param {Array<string>} [employeeIds] 
         * @param {string} [customerId] Filters jobs by a single customer ID (string)
         * @param {string} [page] Paginated page number.
         * @param {Array<string>} [franchiseeIds] Gets jobs from the specified franchisees
         * @param {Array<GetJobsWorkStatusEnum>} [workStatus] Work status filter. Returns jobs from all statuses if empty.
         * @param {number} [pageSize] Number of jobs returned per page.
         * @param {GetJobsSortDirectionEnum} [sortDirection] 
         * @param {Array<string>} [locationIds] Id of locations you want to pull from
         * @param {Array<GetJobsExpandEnum>} [expand] Array of strings to expand response body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobs: async (scheduledStartMin?: string, scheduledStartMax?: string, scheduledEndMin?: string, scheduledEndMax?: string, employeeIds?: Array<string>, customerId?: string, page?: string, franchiseeIds?: Array<string>, workStatus?: Array<GetJobsWorkStatusEnum>, pageSize?: number, sortDirection?: GetJobsSortDirectionEnum, locationIds?: Array<string>, expand?: Array<GetJobsExpandEnum>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/jobs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (scheduledStartMin !== undefined) {
                localVarQueryParameter['scheduled_start_min'] = scheduledStartMin;
            }

            if (scheduledStartMax !== undefined) {
                localVarQueryParameter['scheduled_start_max'] = scheduledStartMax;
            }

            if (scheduledEndMin !== undefined) {
                localVarQueryParameter['scheduled_end_min'] = scheduledEndMin;
            }

            if (scheduledEndMax !== undefined) {
                localVarQueryParameter['scheduled_end_max'] = scheduledEndMax;
            }

            if (employeeIds) {
                localVarQueryParameter['employee_ids'] = employeeIds;
            }

            if (customerId !== undefined) {
                localVarQueryParameter['customer_id'] = customerId;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (franchiseeIds) {
                localVarQueryParameter['franchisee_ids'] = franchiseeIds;
            }

            if (workStatus) {
                localVarQueryParameter['work_status'] = workStatus;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (sortDirection !== undefined) {
                localVarQueryParameter['sort_direction'] = sortDirection;
            }

            if (locationIds) {
                localVarQueryParameter['location_ids'] = locationIds;
            }

            if (expand) {
                localVarQueryParameter['expand'] = expand;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a job by ID.
         * @summary Get a Job
         * @param {string} id The ID of the job 
         * @param {Array<GetJobsIdExpandEnum>} [expand] Array of strings to expand response body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobsId: async (id: string, expand?: Array<GetJobsIdExpandEnum>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getJobsId', 'id', id)
            const localVarPath = `/jobs/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (expand) {
                localVarQueryParameter['expand'] = expand;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists all line items for a job
         * @summary Lists all line items for a job
         * @param {string} jobId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobsJobIdLineItems: async (jobId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('getJobsJobIdLineItems', 'jobId', jobId)
            const localVarPath = `/jobs/{job_id}/line_items`
                .replace(`{${"job_id"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a job with the ID for an already existing address and customer.
         * @summary Create a Job
         * @param {JobCreate} [jobCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postJobs: async (jobCreate?: JobCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/jobs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(jobCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add an attachment to a job.
         * @summary Add an Attachment to a Job
         * @param {string} jobId 
         * @param {File} file A binary file from your local machine
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postJobsJobIdAttachments: async (jobId: string, file: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('postJobsJobIdAttachments', 'jobId', jobId)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('postJobsJobIdAttachments', 'file', file)
            const localVarPath = `/jobs/{job_id}/attachments`
                .replace(`{${"job_id"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add a line item to a job. This is a rate limited request. If you intend to create multiple line items for the same job use Bulk update a job\'s line items request.
         * @summary Add a line item to a Job
         * @param {string} jobId 
         * @param {LineItem} [lineItem] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postJobsJobIdLineItems: async (jobId: string, lineItem?: LineItem, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('postJobsJobIdLineItems', 'jobId', jobId)
            const localVarPath = `/jobs/{job_id}/line_items`
                .replace(`{${"job_id"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(lineItem, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add a note to a job.
         * @summary Add job note
         * @param {string} jobId 
         * @param {PostJobsJobIdNotesRequest} [postJobsJobIdNotesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postJobsJobIdNotes: async (jobId: string, postJobsJobIdNotesRequest?: PostJobsJobIdNotesRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('postJobsJobIdNotes', 'jobId', jobId)
            const localVarPath = `/jobs/{job_id}/notes`
                .replace(`{${"job_id"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApplicationAPIKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication CompanyAPIKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication HousecallUserOAuthToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "HousecallUserOAuthToken", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postJobsJobIdNotesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add a tag to a job.
         * @summary Add job tag
         * @param {string} jobId 
         * @param {PostJobsJobIdTagsRequest} [postJobsJobIdTagsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postJobsJobIdTags: async (jobId: string, postJobsJobIdTagsRequest?: PostJobsJobIdTagsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('postJobsJobIdTags', 'jobId', jobId)
            const localVarPath = `/jobs/{job_id}/tags`
                .replace(`{${"job_id"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApplicationAPIKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication CompanyAPIKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication HousecallUserOAuthToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "HousecallUserOAuthToken", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postJobsJobIdTagsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Bulk update a job\'s line items. If uuid not define for a line item it will be consider as a new line item for the job.
         * @summary Bulk update a job\'s line items
         * @param {string} jobId 
         * @param {Array<LineItem>} [lineItem] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putJobsJobIdLineItems: async (jobId: string, lineItem?: Array<LineItem>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('putJobsJobIdLineItems', 'jobId', jobId)
            const localVarPath = `/jobs/{job_id}/line_items/bulk_update`
                .replace(`{${"job_id"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(lineItem, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Dispatch job to employees
         * @summary Dispatch job to employees
         * @param {string} jobId 
         * @param {UpdateJobDispatchRequest} [updateJobDispatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateJobDispatch: async (jobId: string, updateJobDispatchRequest?: UpdateJobDispatchRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('updateJobDispatch', 'jobId', jobId)
            const localVarPath = `/jobs/{job_id}/dispatch`
                .replace(`{${"job_id"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApplicationAPIKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication HousecallUserOAuthToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "HousecallUserOAuthToken", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateJobDispatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a single line item for a job
         * @param {string} jobId 
         * @param {string} id 
         * @param {LineItem} [lineItem] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateJobLineItem: async (jobId: string, id: string, lineItem?: LineItem, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('updateJobLineItem', 'jobId', jobId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateJobLineItem', 'id', id)
            const localVarPath = `/jobs/{job_id}/line_items/{id}`
                .replace(`{${"job_id"}}`, encodeURIComponent(String(jobId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(lineItem, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a jobs schedule. Jobs with multi days feature containing more than 1 appointment can\'t be updated through this endpoint, must use appointments endpoints.
         * @summary Update job schedule
         * @param {string} jobId 
         * @param {UpdateJobScheduleRequest} [updateJobScheduleRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateJobSchedule: async (jobId: string, updateJobScheduleRequest?: UpdateJobScheduleRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('updateJobSchedule', 'jobId', jobId)
            const localVarPath = `/jobs/{job_id}/schedule`
                .replace(`{${"job_id"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApplicationAPIKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication HousecallUserOAuthToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "HousecallUserOAuthToken", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateJobScheduleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * JobsApi - functional programming interface
 * @export
 */
export const JobsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = JobsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new Job link
         * @summary Create Job Link
         * @param {string} jobId 
         * @param {JobLinkCreate} [jobLinkCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createJobLink(jobId: string, jobLinkCreate?: JobLinkCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JobLink>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createJobLink(jobId, jobLinkCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['JobsApi.createJobLink']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a single line item for a job
         * @param {string} jobId 
         * @param {string} id 
         * @param {LineItem} [lineItem] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteJobLineItem(jobId: string, id: string, lineItem?: LineItem, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LineItem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteJobLineItem(jobId, id, lineItem, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['JobsApi.deleteJobLineItem']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Erase schedule on a job
         * @summary Delete job schedule
         * @param {string} jobId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteJobSchedule(jobId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteJobSchedule200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteJobSchedule(jobId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['JobsApi.deleteJobSchedule']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes a specific job note
         * @summary Delete job note
         * @param {string} jobId 
         * @param {string} noteId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteJobsJobIdNotes(jobId: string, noteId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteJobsJobIdNotes(jobId, noteId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['JobsApi.deleteJobsJobIdNotes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Remove a tag from a job
         * @summary Remove job tag
         * @param {string} jobId 
         * @param {string} tagId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteJobsJobIdTagsTagId(jobId: string, tagId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PostJobsJobIdTags201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteJobsJobIdTagsTagId(jobId, tagId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['JobsApi.deleteJobsJobIdTagsTagId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a list of jobs
         * @summary Get Jobs
         * @param {string} [scheduledStartMin] Filters jobs with a starting time greater than or equal to the date sent.
         * @param {string} [scheduledStartMax] Filters jobs with a starting time less than or equal to the date sent.
         * @param {string} [scheduledEndMin] Filters jobs with an end time greater than or equal to the date  sent.
         * @param {string} [scheduledEndMax] Filters jobs with an end time less than or equal to the date sent.
         * @param {Array<string>} [employeeIds] 
         * @param {string} [customerId] Filters jobs by a single customer ID (string)
         * @param {string} [page] Paginated page number.
         * @param {Array<string>} [franchiseeIds] Gets jobs from the specified franchisees
         * @param {Array<GetJobsWorkStatusEnum>} [workStatus] Work status filter. Returns jobs from all statuses if empty.
         * @param {number} [pageSize] Number of jobs returned per page.
         * @param {GetJobsSortDirectionEnum} [sortDirection] 
         * @param {Array<string>} [locationIds] Id of locations you want to pull from
         * @param {Array<GetJobsExpandEnum>} [expand] Array of strings to expand response body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getJobs(scheduledStartMin?: string, scheduledStartMax?: string, scheduledEndMin?: string, scheduledEndMax?: string, employeeIds?: Array<string>, customerId?: string, page?: string, franchiseeIds?: Array<string>, workStatus?: Array<GetJobsWorkStatusEnum>, pageSize?: number, sortDirection?: GetJobsSortDirectionEnum, locationIds?: Array<string>, expand?: Array<GetJobsExpandEnum>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetJobs200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getJobs(scheduledStartMin, scheduledStartMax, scheduledEndMin, scheduledEndMax, employeeIds, customerId, page, franchiseeIds, workStatus, pageSize, sortDirection, locationIds, expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['JobsApi.getJobs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a job by ID.
         * @summary Get a Job
         * @param {string} id The ID of the job 
         * @param {Array<GetJobsIdExpandEnum>} [expand] Array of strings to expand response body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getJobsId(id: string, expand?: Array<GetJobsIdExpandEnum>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Job>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getJobsId(id, expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['JobsApi.getJobsId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Lists all line items for a job
         * @summary Lists all line items for a job
         * @param {string} jobId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getJobsJobIdLineItems(jobId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetJobsJobIdLineItems200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getJobsJobIdLineItems(jobId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['JobsApi.getJobsJobIdLineItems']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a job with the ID for an already existing address and customer.
         * @summary Create a Job
         * @param {JobCreate} [jobCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postJobs(jobCreate?: JobCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Job>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postJobs(jobCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['JobsApi.postJobs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Add an attachment to a job.
         * @summary Add an Attachment to a Job
         * @param {string} jobId 
         * @param {File} file A binary file from your local machine
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postJobsJobIdAttachments(jobId: string, file: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PostJobsJobIdAttachments202Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postJobsJobIdAttachments(jobId, file, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['JobsApi.postJobsJobIdAttachments']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Add a line item to a job. This is a rate limited request. If you intend to create multiple line items for the same job use Bulk update a job\'s line items request.
         * @summary Add a line item to a Job
         * @param {string} jobId 
         * @param {LineItem} [lineItem] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postJobsJobIdLineItems(jobId: string, lineItem?: LineItem, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LineItem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postJobsJobIdLineItems(jobId, lineItem, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['JobsApi.postJobsJobIdLineItems']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Add a note to a job.
         * @summary Add job note
         * @param {string} jobId 
         * @param {PostJobsJobIdNotesRequest} [postJobsJobIdNotesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postJobsJobIdNotes(jobId: string, postJobsJobIdNotesRequest?: PostJobsJobIdNotesRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Note>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postJobsJobIdNotes(jobId, postJobsJobIdNotesRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['JobsApi.postJobsJobIdNotes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Add a tag to a job.
         * @summary Add job tag
         * @param {string} jobId 
         * @param {PostJobsJobIdTagsRequest} [postJobsJobIdTagsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postJobsJobIdTags(jobId: string, postJobsJobIdTagsRequest?: PostJobsJobIdTagsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PostJobsJobIdTags201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postJobsJobIdTags(jobId, postJobsJobIdTagsRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['JobsApi.postJobsJobIdTags']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Bulk update a job\'s line items. If uuid not define for a line item it will be consider as a new line item for the job.
         * @summary Bulk update a job\'s line items
         * @param {string} jobId 
         * @param {Array<LineItem>} [lineItem] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putJobsJobIdLineItems(jobId: string, lineItem?: Array<LineItem>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<LineItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putJobsJobIdLineItems(jobId, lineItem, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['JobsApi.putJobsJobIdLineItems']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Dispatch job to employees
         * @summary Dispatch job to employees
         * @param {string} jobId 
         * @param {UpdateJobDispatchRequest} [updateJobDispatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateJobDispatch(jobId: string, updateJobDispatchRequest?: UpdateJobDispatchRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateJobDispatch200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateJobDispatch(jobId, updateJobDispatchRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['JobsApi.updateJobDispatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a single line item for a job
         * @param {string} jobId 
         * @param {string} id 
         * @param {LineItem} [lineItem] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateJobLineItem(jobId: string, id: string, lineItem?: LineItem, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LineItem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateJobLineItem(jobId, id, lineItem, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['JobsApi.updateJobLineItem']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update a jobs schedule. Jobs with multi days feature containing more than 1 appointment can\'t be updated through this endpoint, must use appointments endpoints.
         * @summary Update job schedule
         * @param {string} jobId 
         * @param {UpdateJobScheduleRequest} [updateJobScheduleRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateJobSchedule(jobId: string, updateJobScheduleRequest?: UpdateJobScheduleRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateJobSchedule200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateJobSchedule(jobId, updateJobScheduleRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['JobsApi.updateJobSchedule']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * JobsApi - factory interface
 * @export
 */
export const JobsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = JobsApiFp(configuration)
    return {
        /**
         * Create a new Job link
         * @summary Create Job Link
         * @param {string} jobId 
         * @param {JobLinkCreate} [jobLinkCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createJobLink(jobId: string, jobLinkCreate?: JobLinkCreate, options?: RawAxiosRequestConfig): AxiosPromise<JobLink> {
            return localVarFp.createJobLink(jobId, jobLinkCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a single line item for a job
         * @param {string} jobId 
         * @param {string} id 
         * @param {LineItem} [lineItem] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteJobLineItem(jobId: string, id: string, lineItem?: LineItem, options?: RawAxiosRequestConfig): AxiosPromise<LineItem> {
            return localVarFp.deleteJobLineItem(jobId, id, lineItem, options).then((request) => request(axios, basePath));
        },
        /**
         * Erase schedule on a job
         * @summary Delete job schedule
         * @param {string} jobId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteJobSchedule(jobId: string, options?: RawAxiosRequestConfig): AxiosPromise<DeleteJobSchedule200Response> {
            return localVarFp.deleteJobSchedule(jobId, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a specific job note
         * @summary Delete job note
         * @param {string} jobId 
         * @param {string} noteId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteJobsJobIdNotes(jobId: string, noteId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteJobsJobIdNotes(jobId, noteId, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove a tag from a job
         * @summary Remove job tag
         * @param {string} jobId 
         * @param {string} tagId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteJobsJobIdTagsTagId(jobId: string, tagId: string, options?: RawAxiosRequestConfig): AxiosPromise<PostJobsJobIdTags201Response> {
            return localVarFp.deleteJobsJobIdTagsTagId(jobId, tagId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of jobs
         * @summary Get Jobs
         * @param {string} [scheduledStartMin] Filters jobs with a starting time greater than or equal to the date sent.
         * @param {string} [scheduledStartMax] Filters jobs with a starting time less than or equal to the date sent.
         * @param {string} [scheduledEndMin] Filters jobs with an end time greater than or equal to the date  sent.
         * @param {string} [scheduledEndMax] Filters jobs with an end time less than or equal to the date sent.
         * @param {Array<string>} [employeeIds] 
         * @param {string} [customerId] Filters jobs by a single customer ID (string)
         * @param {string} [page] Paginated page number.
         * @param {Array<string>} [franchiseeIds] Gets jobs from the specified franchisees
         * @param {Array<GetJobsWorkStatusEnum>} [workStatus] Work status filter. Returns jobs from all statuses if empty.
         * @param {number} [pageSize] Number of jobs returned per page.
         * @param {GetJobsSortDirectionEnum} [sortDirection] 
         * @param {Array<string>} [locationIds] Id of locations you want to pull from
         * @param {Array<GetJobsExpandEnum>} [expand] Array of strings to expand response body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobs(scheduledStartMin?: string, scheduledStartMax?: string, scheduledEndMin?: string, scheduledEndMax?: string, employeeIds?: Array<string>, customerId?: string, page?: string, franchiseeIds?: Array<string>, workStatus?: Array<GetJobsWorkStatusEnum>, pageSize?: number, sortDirection?: GetJobsSortDirectionEnum, locationIds?: Array<string>, expand?: Array<GetJobsExpandEnum>, options?: RawAxiosRequestConfig): AxiosPromise<GetJobs200Response> {
            return localVarFp.getJobs(scheduledStartMin, scheduledStartMax, scheduledEndMin, scheduledEndMax, employeeIds, customerId, page, franchiseeIds, workStatus, pageSize, sortDirection, locationIds, expand, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a job by ID.
         * @summary Get a Job
         * @param {string} id The ID of the job 
         * @param {Array<GetJobsIdExpandEnum>} [expand] Array of strings to expand response body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobsId(id: string, expand?: Array<GetJobsIdExpandEnum>, options?: RawAxiosRequestConfig): AxiosPromise<Job> {
            return localVarFp.getJobsId(id, expand, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists all line items for a job
         * @summary Lists all line items for a job
         * @param {string} jobId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobsJobIdLineItems(jobId: string, options?: RawAxiosRequestConfig): AxiosPromise<GetJobsJobIdLineItems200Response> {
            return localVarFp.getJobsJobIdLineItems(jobId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a job with the ID for an already existing address and customer.
         * @summary Create a Job
         * @param {JobCreate} [jobCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postJobs(jobCreate?: JobCreate, options?: RawAxiosRequestConfig): AxiosPromise<Job> {
            return localVarFp.postJobs(jobCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * Add an attachment to a job.
         * @summary Add an Attachment to a Job
         * @param {string} jobId 
         * @param {File} file A binary file from your local machine
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postJobsJobIdAttachments(jobId: string, file: File, options?: RawAxiosRequestConfig): AxiosPromise<PostJobsJobIdAttachments202Response> {
            return localVarFp.postJobsJobIdAttachments(jobId, file, options).then((request) => request(axios, basePath));
        },
        /**
         * Add a line item to a job. This is a rate limited request. If you intend to create multiple line items for the same job use Bulk update a job\'s line items request.
         * @summary Add a line item to a Job
         * @param {string} jobId 
         * @param {LineItem} [lineItem] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postJobsJobIdLineItems(jobId: string, lineItem?: LineItem, options?: RawAxiosRequestConfig): AxiosPromise<LineItem> {
            return localVarFp.postJobsJobIdLineItems(jobId, lineItem, options).then((request) => request(axios, basePath));
        },
        /**
         * Add a note to a job.
         * @summary Add job note
         * @param {string} jobId 
         * @param {PostJobsJobIdNotesRequest} [postJobsJobIdNotesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postJobsJobIdNotes(jobId: string, postJobsJobIdNotesRequest?: PostJobsJobIdNotesRequest, options?: RawAxiosRequestConfig): AxiosPromise<Note> {
            return localVarFp.postJobsJobIdNotes(jobId, postJobsJobIdNotesRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Add a tag to a job.
         * @summary Add job tag
         * @param {string} jobId 
         * @param {PostJobsJobIdTagsRequest} [postJobsJobIdTagsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postJobsJobIdTags(jobId: string, postJobsJobIdTagsRequest?: PostJobsJobIdTagsRequest, options?: RawAxiosRequestConfig): AxiosPromise<PostJobsJobIdTags201Response> {
            return localVarFp.postJobsJobIdTags(jobId, postJobsJobIdTagsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Bulk update a job\'s line items. If uuid not define for a line item it will be consider as a new line item for the job.
         * @summary Bulk update a job\'s line items
         * @param {string} jobId 
         * @param {Array<LineItem>} [lineItem] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putJobsJobIdLineItems(jobId: string, lineItem?: Array<LineItem>, options?: RawAxiosRequestConfig): AxiosPromise<Array<LineItem>> {
            return localVarFp.putJobsJobIdLineItems(jobId, lineItem, options).then((request) => request(axios, basePath));
        },
        /**
         * Dispatch job to employees
         * @summary Dispatch job to employees
         * @param {string} jobId 
         * @param {UpdateJobDispatchRequest} [updateJobDispatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateJobDispatch(jobId: string, updateJobDispatchRequest?: UpdateJobDispatchRequest, options?: RawAxiosRequestConfig): AxiosPromise<UpdateJobDispatch200Response> {
            return localVarFp.updateJobDispatch(jobId, updateJobDispatchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a single line item for a job
         * @param {string} jobId 
         * @param {string} id 
         * @param {LineItem} [lineItem] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateJobLineItem(jobId: string, id: string, lineItem?: LineItem, options?: RawAxiosRequestConfig): AxiosPromise<LineItem> {
            return localVarFp.updateJobLineItem(jobId, id, lineItem, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a jobs schedule. Jobs with multi days feature containing more than 1 appointment can\'t be updated through this endpoint, must use appointments endpoints.
         * @summary Update job schedule
         * @param {string} jobId 
         * @param {UpdateJobScheduleRequest} [updateJobScheduleRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateJobSchedule(jobId: string, updateJobScheduleRequest?: UpdateJobScheduleRequest, options?: RawAxiosRequestConfig): AxiosPromise<UpdateJobSchedule200Response> {
            return localVarFp.updateJobSchedule(jobId, updateJobScheduleRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * JobsApi - object-oriented interface
 * @export
 * @class JobsApi
 * @extends {BaseAPI}
 */
export class JobsApi extends BaseAPI {
    /**
     * Create a new Job link
     * @summary Create Job Link
     * @param {string} jobId 
     * @param {JobLinkCreate} [jobLinkCreate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobsApi
     */
    public createJobLink(jobId: string, jobLinkCreate?: JobLinkCreate, options?: RawAxiosRequestConfig) {
        return JobsApiFp(this.configuration).createJobLink(jobId, jobLinkCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a single line item for a job
     * @param {string} jobId 
     * @param {string} id 
     * @param {LineItem} [lineItem] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobsApi
     */
    public deleteJobLineItem(jobId: string, id: string, lineItem?: LineItem, options?: RawAxiosRequestConfig) {
        return JobsApiFp(this.configuration).deleteJobLineItem(jobId, id, lineItem, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Erase schedule on a job
     * @summary Delete job schedule
     * @param {string} jobId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobsApi
     */
    public deleteJobSchedule(jobId: string, options?: RawAxiosRequestConfig) {
        return JobsApiFp(this.configuration).deleteJobSchedule(jobId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a specific job note
     * @summary Delete job note
     * @param {string} jobId 
     * @param {string} noteId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobsApi
     */
    public deleteJobsJobIdNotes(jobId: string, noteId: string, options?: RawAxiosRequestConfig) {
        return JobsApiFp(this.configuration).deleteJobsJobIdNotes(jobId, noteId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove a tag from a job
     * @summary Remove job tag
     * @param {string} jobId 
     * @param {string} tagId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobsApi
     */
    public deleteJobsJobIdTagsTagId(jobId: string, tagId: string, options?: RawAxiosRequestConfig) {
        return JobsApiFp(this.configuration).deleteJobsJobIdTagsTagId(jobId, tagId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of jobs
     * @summary Get Jobs
     * @param {string} [scheduledStartMin] Filters jobs with a starting time greater than or equal to the date sent.
     * @param {string} [scheduledStartMax] Filters jobs with a starting time less than or equal to the date sent.
     * @param {string} [scheduledEndMin] Filters jobs with an end time greater than or equal to the date  sent.
     * @param {string} [scheduledEndMax] Filters jobs with an end time less than or equal to the date sent.
     * @param {Array<string>} [employeeIds] 
     * @param {string} [customerId] Filters jobs by a single customer ID (string)
     * @param {string} [page] Paginated page number.
     * @param {Array<string>} [franchiseeIds] Gets jobs from the specified franchisees
     * @param {Array<GetJobsWorkStatusEnum>} [workStatus] Work status filter. Returns jobs from all statuses if empty.
     * @param {number} [pageSize] Number of jobs returned per page.
     * @param {GetJobsSortDirectionEnum} [sortDirection] 
     * @param {Array<string>} [locationIds] Id of locations you want to pull from
     * @param {Array<GetJobsExpandEnum>} [expand] Array of strings to expand response body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobsApi
     */
    public getJobs(scheduledStartMin?: string, scheduledStartMax?: string, scheduledEndMin?: string, scheduledEndMax?: string, employeeIds?: Array<string>, customerId?: string, page?: string, franchiseeIds?: Array<string>, workStatus?: Array<GetJobsWorkStatusEnum>, pageSize?: number, sortDirection?: GetJobsSortDirectionEnum, locationIds?: Array<string>, expand?: Array<GetJobsExpandEnum>, options?: RawAxiosRequestConfig) {
        return JobsApiFp(this.configuration).getJobs(scheduledStartMin, scheduledStartMax, scheduledEndMin, scheduledEndMax, employeeIds, customerId, page, franchiseeIds, workStatus, pageSize, sortDirection, locationIds, expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a job by ID.
     * @summary Get a Job
     * @param {string} id The ID of the job 
     * @param {Array<GetJobsIdExpandEnum>} [expand] Array of strings to expand response body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobsApi
     */
    public getJobsId(id: string, expand?: Array<GetJobsIdExpandEnum>, options?: RawAxiosRequestConfig) {
        return JobsApiFp(this.configuration).getJobsId(id, expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists all line items for a job
     * @summary Lists all line items for a job
     * @param {string} jobId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobsApi
     */
    public getJobsJobIdLineItems(jobId: string, options?: RawAxiosRequestConfig) {
        return JobsApiFp(this.configuration).getJobsJobIdLineItems(jobId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a job with the ID for an already existing address and customer.
     * @summary Create a Job
     * @param {JobCreate} [jobCreate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobsApi
     */
    public postJobs(jobCreate?: JobCreate, options?: RawAxiosRequestConfig) {
        return JobsApiFp(this.configuration).postJobs(jobCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add an attachment to a job.
     * @summary Add an Attachment to a Job
     * @param {string} jobId 
     * @param {File} file A binary file from your local machine
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobsApi
     */
    public postJobsJobIdAttachments(jobId: string, file: File, options?: RawAxiosRequestConfig) {
        return JobsApiFp(this.configuration).postJobsJobIdAttachments(jobId, file, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add a line item to a job. This is a rate limited request. If you intend to create multiple line items for the same job use Bulk update a job\'s line items request.
     * @summary Add a line item to a Job
     * @param {string} jobId 
     * @param {LineItem} [lineItem] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobsApi
     */
    public postJobsJobIdLineItems(jobId: string, lineItem?: LineItem, options?: RawAxiosRequestConfig) {
        return JobsApiFp(this.configuration).postJobsJobIdLineItems(jobId, lineItem, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add a note to a job.
     * @summary Add job note
     * @param {string} jobId 
     * @param {PostJobsJobIdNotesRequest} [postJobsJobIdNotesRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobsApi
     */
    public postJobsJobIdNotes(jobId: string, postJobsJobIdNotesRequest?: PostJobsJobIdNotesRequest, options?: RawAxiosRequestConfig) {
        return JobsApiFp(this.configuration).postJobsJobIdNotes(jobId, postJobsJobIdNotesRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add a tag to a job.
     * @summary Add job tag
     * @param {string} jobId 
     * @param {PostJobsJobIdTagsRequest} [postJobsJobIdTagsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobsApi
     */
    public postJobsJobIdTags(jobId: string, postJobsJobIdTagsRequest?: PostJobsJobIdTagsRequest, options?: RawAxiosRequestConfig) {
        return JobsApiFp(this.configuration).postJobsJobIdTags(jobId, postJobsJobIdTagsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Bulk update a job\'s line items. If uuid not define for a line item it will be consider as a new line item for the job.
     * @summary Bulk update a job\'s line items
     * @param {string} jobId 
     * @param {Array<LineItem>} [lineItem] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobsApi
     */
    public putJobsJobIdLineItems(jobId: string, lineItem?: Array<LineItem>, options?: RawAxiosRequestConfig) {
        return JobsApiFp(this.configuration).putJobsJobIdLineItems(jobId, lineItem, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Dispatch job to employees
     * @summary Dispatch job to employees
     * @param {string} jobId 
     * @param {UpdateJobDispatchRequest} [updateJobDispatchRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobsApi
     */
    public updateJobDispatch(jobId: string, updateJobDispatchRequest?: UpdateJobDispatchRequest, options?: RawAxiosRequestConfig) {
        return JobsApiFp(this.configuration).updateJobDispatch(jobId, updateJobDispatchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a single line item for a job
     * @param {string} jobId 
     * @param {string} id 
     * @param {LineItem} [lineItem] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobsApi
     */
    public updateJobLineItem(jobId: string, id: string, lineItem?: LineItem, options?: RawAxiosRequestConfig) {
        return JobsApiFp(this.configuration).updateJobLineItem(jobId, id, lineItem, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a jobs schedule. Jobs with multi days feature containing more than 1 appointment can\'t be updated through this endpoint, must use appointments endpoints.
     * @summary Update job schedule
     * @param {string} jobId 
     * @param {UpdateJobScheduleRequest} [updateJobScheduleRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobsApi
     */
    public updateJobSchedule(jobId: string, updateJobScheduleRequest?: UpdateJobScheduleRequest, options?: RawAxiosRequestConfig) {
        return JobsApiFp(this.configuration).updateJobSchedule(jobId, updateJobScheduleRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const GetJobsWorkStatusEnum = {
    Unscheduled: 'unscheduled',
    Scheduled: 'scheduled',
    InProgress: 'in_progress',
    Completed: 'completed',
    Canceled: 'canceled'
} as const;
export type GetJobsWorkStatusEnum = typeof GetJobsWorkStatusEnum[keyof typeof GetJobsWorkStatusEnum];
/**
 * @export
 */
export const GetJobsSortDirectionEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type GetJobsSortDirectionEnum = typeof GetJobsSortDirectionEnum[keyof typeof GetJobsSortDirectionEnum];
/**
 * @export
 */
export const GetJobsExpandEnum = {
    Attachments: 'attachments',
    Appointments: 'appointments'
} as const;
export type GetJobsExpandEnum = typeof GetJobsExpandEnum[keyof typeof GetJobsExpandEnum];
/**
 * @export
 */
export const GetJobsIdExpandEnum = {
    Attachments: 'attachments',
    Appointments: 'appointments'
} as const;
export type GetJobsIdExpandEnum = typeof GetJobsIdExpandEnum[keyof typeof GetJobsIdExpandEnum];


/**
 * LeadSourcesApi - axios parameter creator
 * @export
 */
export const LeadSourcesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get a list of available lead sources.
         * @summary Get Lead Sources
         * @param {string} [q] A query that can be used to search for a lead source by name
         * @param {number} [page] Current Page
         * @param {number} [pageSize] Number of lead sources per page
         * @param {GetLeadSourcesSortDirectionEnum} [sortDirection] Ascending or descending
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLeadSources: async (q?: string, page?: number, pageSize?: number, sortDirection?: GetLeadSourcesSortDirectionEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/lead_sources`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApplicationAPIKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication CompanyAPIKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication HousecallUserOAuthToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "HousecallUserOAuthToken", [], configuration)

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (sortDirection !== undefined) {
                localVarQueryParameter['sort_direction'] = sortDirection;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a lead source
         * @summary Create lead source
         * @param {PostLeadSourcesRequest} [postLeadSourcesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postLeadSources: async (postLeadSourcesRequest?: PostLeadSourcesRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/lead_sources`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApplicationAPIKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication CompanyAPIKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication HousecallUserOAuthToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "HousecallUserOAuthToken", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postLeadSourcesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a specific lead source. Only lead sources marked as editable can be updated.
         * @summary Update Lead Source
         * @param {string} leadSourceId 
         * @param {PostTagsRequest} [postTagsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putLeadSourcesLeadSourceId: async (leadSourceId: string, postTagsRequest?: PostTagsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'leadSourceId' is not null or undefined
            assertParamExists('putLeadSourcesLeadSourceId', 'leadSourceId', leadSourceId)
            const localVarPath = `/lead_sources/{lead_source_id}`
                .replace(`{${"lead_source_id"}}`, encodeURIComponent(String(leadSourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApplicationAPIKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication CompanyAPIKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication HousecallUserOAuthToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "HousecallUserOAuthToken", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postTagsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LeadSourcesApi - functional programming interface
 * @export
 */
export const LeadSourcesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LeadSourcesApiAxiosParamCreator(configuration)
    return {
        /**
         * Get a list of available lead sources.
         * @summary Get Lead Sources
         * @param {string} [q] A query that can be used to search for a lead source by name
         * @param {number} [page] Current Page
         * @param {number} [pageSize] Number of lead sources per page
         * @param {GetLeadSourcesSortDirectionEnum} [sortDirection] Ascending or descending
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLeadSources(q?: string, page?: number, pageSize?: number, sortDirection?: GetLeadSourcesSortDirectionEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetLeadSources200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLeadSources(q, page, pageSize, sortDirection, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LeadSourcesApi.getLeadSources']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a lead source
         * @summary Create lead source
         * @param {PostLeadSourcesRequest} [postLeadSourcesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postLeadSources(postLeadSourcesRequest?: PostLeadSourcesRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LeadSource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postLeadSources(postLeadSourcesRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LeadSourcesApi.postLeadSources']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update a specific lead source. Only lead sources marked as editable can be updated.
         * @summary Update Lead Source
         * @param {string} leadSourceId 
         * @param {PostTagsRequest} [postTagsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putLeadSourcesLeadSourceId(leadSourceId: string, postTagsRequest?: PostTagsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LeadSource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putLeadSourcesLeadSourceId(leadSourceId, postTagsRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LeadSourcesApi.putLeadSourcesLeadSourceId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * LeadSourcesApi - factory interface
 * @export
 */
export const LeadSourcesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LeadSourcesApiFp(configuration)
    return {
        /**
         * Get a list of available lead sources.
         * @summary Get Lead Sources
         * @param {string} [q] A query that can be used to search for a lead source by name
         * @param {number} [page] Current Page
         * @param {number} [pageSize] Number of lead sources per page
         * @param {GetLeadSourcesSortDirectionEnum} [sortDirection] Ascending or descending
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLeadSources(q?: string, page?: number, pageSize?: number, sortDirection?: GetLeadSourcesSortDirectionEnum, options?: RawAxiosRequestConfig): AxiosPromise<GetLeadSources200Response> {
            return localVarFp.getLeadSources(q, page, pageSize, sortDirection, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a lead source
         * @summary Create lead source
         * @param {PostLeadSourcesRequest} [postLeadSourcesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postLeadSources(postLeadSourcesRequest?: PostLeadSourcesRequest, options?: RawAxiosRequestConfig): AxiosPromise<LeadSource> {
            return localVarFp.postLeadSources(postLeadSourcesRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a specific lead source. Only lead sources marked as editable can be updated.
         * @summary Update Lead Source
         * @param {string} leadSourceId 
         * @param {PostTagsRequest} [postTagsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putLeadSourcesLeadSourceId(leadSourceId: string, postTagsRequest?: PostTagsRequest, options?: RawAxiosRequestConfig): AxiosPromise<LeadSource> {
            return localVarFp.putLeadSourcesLeadSourceId(leadSourceId, postTagsRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LeadSourcesApi - object-oriented interface
 * @export
 * @class LeadSourcesApi
 * @extends {BaseAPI}
 */
export class LeadSourcesApi extends BaseAPI {
    /**
     * Get a list of available lead sources.
     * @summary Get Lead Sources
     * @param {string} [q] A query that can be used to search for a lead source by name
     * @param {number} [page] Current Page
     * @param {number} [pageSize] Number of lead sources per page
     * @param {GetLeadSourcesSortDirectionEnum} [sortDirection] Ascending or descending
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeadSourcesApi
     */
    public getLeadSources(q?: string, page?: number, pageSize?: number, sortDirection?: GetLeadSourcesSortDirectionEnum, options?: RawAxiosRequestConfig) {
        return LeadSourcesApiFp(this.configuration).getLeadSources(q, page, pageSize, sortDirection, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a lead source
     * @summary Create lead source
     * @param {PostLeadSourcesRequest} [postLeadSourcesRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeadSourcesApi
     */
    public postLeadSources(postLeadSourcesRequest?: PostLeadSourcesRequest, options?: RawAxiosRequestConfig) {
        return LeadSourcesApiFp(this.configuration).postLeadSources(postLeadSourcesRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a specific lead source. Only lead sources marked as editable can be updated.
     * @summary Update Lead Source
     * @param {string} leadSourceId 
     * @param {PostTagsRequest} [postTagsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeadSourcesApi
     */
    public putLeadSourcesLeadSourceId(leadSourceId: string, postTagsRequest?: PostTagsRequest, options?: RawAxiosRequestConfig) {
        return LeadSourcesApiFp(this.configuration).putLeadSourcesLeadSourceId(leadSourceId, postTagsRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const GetLeadSourcesSortDirectionEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type GetLeadSourcesSortDirectionEnum = typeof GetLeadSourcesSortDirectionEnum[keyof typeof GetLeadSourcesSortDirectionEnum];


/**
 * LeadsApi - axios parameter creator
 * @export
 */
export const LeadsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get a list of leads
         * @summary Get Leads
         * @param {Array<string>} [employeeIds] Filters leads by a list of employee IDs (string)
         * @param {string} [customerId] Filters leads by a single customer ID (string)
         * @param {string} [page] Paginated page number.
         * @param {GetLeadsStatusEnum} [status] Filters leads by status
         * @param {number} [pageSize] Number of jobs returned per page.
         * @param {GetLeadsSortDirectionEnum} [sortDirection] 
         * @param {Array<string>} [tagIds] Filters leads by a list of tags
         * @param {Array<string>} [leadSource] Filters leads by a single lead_source
         * @param {string} [locationIds] Id of locations you want to pull from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLeads: async (employeeIds?: Array<string>, customerId?: string, page?: string, status?: GetLeadsStatusEnum, pageSize?: number, sortDirection?: GetLeadsSortDirectionEnum, tagIds?: Array<string>, leadSource?: Array<string>, locationIds?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/leads`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApplicationAPIKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication CompanyAPIKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication HousecallUserOAuthToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "HousecallUserOAuthToken", [], configuration)

            if (employeeIds) {
                localVarQueryParameter['employee_ids'] = employeeIds;
            }

            if (customerId !== undefined) {
                localVarQueryParameter['customer_id'] = customerId;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (status) {
                localVarQueryParameter['status'] = status;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (sortDirection !== undefined) {
                localVarQueryParameter['sort_direction'] = sortDirection;
            }

            if (tagIds) {
                localVarQueryParameter['tag_ids'] = tagIds;
            }

            if (leadSource) {
                localVarQueryParameter['lead_source'] = leadSource;
            }

            if (locationIds !== undefined) {
                localVarQueryParameter['location_ids'] = locationIds;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the lead via ID.
         * @summary Get Lead
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLeadsId: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getLeadsId', 'id', id)
            const localVarPath = `/leads/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApplicationAPIKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication CompanyAPIKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication HousecallUserOAuthToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "HousecallUserOAuthToken", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a lead with the ID for an already existing customer.
         * @summary Create Lead
         * @param {LeadCreate} [leadCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postLeads: async (leadCreate?: LeadCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/leads`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApplicationAPIKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication CompanyAPIKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication HousecallUserOAuthToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "HousecallUserOAuthToken", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(leadCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LeadsApi - functional programming interface
 * @export
 */
export const LeadsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LeadsApiAxiosParamCreator(configuration)
    return {
        /**
         * Get a list of leads
         * @summary Get Leads
         * @param {Array<string>} [employeeIds] Filters leads by a list of employee IDs (string)
         * @param {string} [customerId] Filters leads by a single customer ID (string)
         * @param {string} [page] Paginated page number.
         * @param {GetLeadsStatusEnum} [status] Filters leads by status
         * @param {number} [pageSize] Number of jobs returned per page.
         * @param {GetLeadsSortDirectionEnum} [sortDirection] 
         * @param {Array<string>} [tagIds] Filters leads by a list of tags
         * @param {Array<string>} [leadSource] Filters leads by a single lead_source
         * @param {string} [locationIds] Id of locations you want to pull from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLeads(employeeIds?: Array<string>, customerId?: string, page?: string, status?: GetLeadsStatusEnum, pageSize?: number, sortDirection?: GetLeadsSortDirectionEnum, tagIds?: Array<string>, leadSource?: Array<string>, locationIds?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetLeads200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLeads(employeeIds, customerId, page, status, pageSize, sortDirection, tagIds, leadSource, locationIds, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LeadsApi.getLeads']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the lead via ID.
         * @summary Get Lead
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLeadsId(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Lead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLeadsId(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LeadsApi.getLeadsId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a lead with the ID for an already existing customer.
         * @summary Create Lead
         * @param {LeadCreate} [leadCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postLeads(leadCreate?: LeadCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Lead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postLeads(leadCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LeadsApi.postLeads']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * LeadsApi - factory interface
 * @export
 */
export const LeadsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LeadsApiFp(configuration)
    return {
        /**
         * Get a list of leads
         * @summary Get Leads
         * @param {Array<string>} [employeeIds] Filters leads by a list of employee IDs (string)
         * @param {string} [customerId] Filters leads by a single customer ID (string)
         * @param {string} [page] Paginated page number.
         * @param {GetLeadsStatusEnum} [status] Filters leads by status
         * @param {number} [pageSize] Number of jobs returned per page.
         * @param {GetLeadsSortDirectionEnum} [sortDirection] 
         * @param {Array<string>} [tagIds] Filters leads by a list of tags
         * @param {Array<string>} [leadSource] Filters leads by a single lead_source
         * @param {string} [locationIds] Id of locations you want to pull from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLeads(employeeIds?: Array<string>, customerId?: string, page?: string, status?: GetLeadsStatusEnum, pageSize?: number, sortDirection?: GetLeadsSortDirectionEnum, tagIds?: Array<string>, leadSource?: Array<string>, locationIds?: string, options?: RawAxiosRequestConfig): AxiosPromise<GetLeads200Response> {
            return localVarFp.getLeads(employeeIds, customerId, page, status, pageSize, sortDirection, tagIds, leadSource, locationIds, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the lead via ID.
         * @summary Get Lead
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLeadsId(id: string, options?: RawAxiosRequestConfig): AxiosPromise<Lead> {
            return localVarFp.getLeadsId(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a lead with the ID for an already existing customer.
         * @summary Create Lead
         * @param {LeadCreate} [leadCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postLeads(leadCreate?: LeadCreate, options?: RawAxiosRequestConfig): AxiosPromise<Lead> {
            return localVarFp.postLeads(leadCreate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LeadsApi - object-oriented interface
 * @export
 * @class LeadsApi
 * @extends {BaseAPI}
 */
export class LeadsApi extends BaseAPI {
    /**
     * Get a list of leads
     * @summary Get Leads
     * @param {Array<string>} [employeeIds] Filters leads by a list of employee IDs (string)
     * @param {string} [customerId] Filters leads by a single customer ID (string)
     * @param {string} [page] Paginated page number.
     * @param {GetLeadsStatusEnum} [status] Filters leads by status
     * @param {number} [pageSize] Number of jobs returned per page.
     * @param {GetLeadsSortDirectionEnum} [sortDirection] 
     * @param {Array<string>} [tagIds] Filters leads by a list of tags
     * @param {Array<string>} [leadSource] Filters leads by a single lead_source
     * @param {string} [locationIds] Id of locations you want to pull from
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeadsApi
     */
    public getLeads(employeeIds?: Array<string>, customerId?: string, page?: string, status?: GetLeadsStatusEnum, pageSize?: number, sortDirection?: GetLeadsSortDirectionEnum, tagIds?: Array<string>, leadSource?: Array<string>, locationIds?: string, options?: RawAxiosRequestConfig) {
        return LeadsApiFp(this.configuration).getLeads(employeeIds, customerId, page, status, pageSize, sortDirection, tagIds, leadSource, locationIds, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the lead via ID.
     * @summary Get Lead
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeadsApi
     */
    public getLeadsId(id: string, options?: RawAxiosRequestConfig) {
        return LeadsApiFp(this.configuration).getLeadsId(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a lead with the ID for an already existing customer.
     * @summary Create Lead
     * @param {LeadCreate} [leadCreate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeadsApi
     */
    public postLeads(leadCreate?: LeadCreate, options?: RawAxiosRequestConfig) {
        return LeadsApiFp(this.configuration).postLeads(leadCreate, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const GetLeadsStatusEnum = {
    Unscheduled: 'unscheduled',
    Scheduled: 'scheduled',
    InProgress: 'in_progress',
    Completed: 'completed',
    Canceled: 'canceled'
} as const;
export type GetLeadsStatusEnum = typeof GetLeadsStatusEnum[keyof typeof GetLeadsStatusEnum];
/**
 * @export
 */
export const GetLeadsSortDirectionEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type GetLeadsSortDirectionEnum = typeof GetLeadsSortDirectionEnum[keyof typeof GetLeadsSortDirectionEnum];


/**
 * MaterialCategoriesApi - axios parameter creator
 * @export
 */
export const MaterialCategoriesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new price book material category
         * @summary Create Material Category
         * @param {CreateMaterialCategoryRequest} createMaterialCategoryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMaterialCategory: async (createMaterialCategoryRequest: CreateMaterialCategoryRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createMaterialCategoryRequest' is not null or undefined
            assertParamExists('createMaterialCategory', 'createMaterialCategoryRequest', createMaterialCategoryRequest)
            const localVarPath = `/api/price_book/material_categories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CompanyAPIKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication HousecallUserOAuthToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "HousecallUserOAuthToken", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createMaterialCategoryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an existing price book material category
         * @summary Delete Material Category
         * @param {string} uuid UUID of the material category to be updated.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMaterialCategory: async (uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('deleteMaterialCategory', 'uuid', uuid)
            const localVarPath = `/api/price_book/material_categories/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CompanyAPIKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication HousecallUserOAuthToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "HousecallUserOAuthToken", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all price book material categories from root or under a parent category
         * @summary Get Material Categories
         * @param {string} [parentUuid] Including the UUID of a specific material category will fetch all material categories that reside under that category. Not including a UUID will fetch all root level categories.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        indexMaterialCategories: async (parentUuid?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/price_book/material_categories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CompanyAPIKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication HousecallUserOAuthToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "HousecallUserOAuthToken", [], configuration)

            if (parentUuid !== undefined) {
                localVarQueryParameter['parent_uuid'] = parentUuid;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update information of an existing price book material category
         * @summary Update Material Category
         * @param {string} uuid UUID of the material category to be updated.
         * @param {PostTagsRequest} postTagsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMaterialCategory: async (uuid: string, postTagsRequest: PostTagsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('updateMaterialCategory', 'uuid', uuid)
            // verify required parameter 'postTagsRequest' is not null or undefined
            assertParamExists('updateMaterialCategory', 'postTagsRequest', postTagsRequest)
            const localVarPath = `/api/price_book/material_categories/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CompanyAPIKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication HousecallUserOAuthToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "HousecallUserOAuthToken", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postTagsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MaterialCategoriesApi - functional programming interface
 * @export
 */
export const MaterialCategoriesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MaterialCategoriesApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new price book material category
         * @summary Create Material Category
         * @param {CreateMaterialCategoryRequest} createMaterialCategoryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createMaterialCategory(createMaterialCategoryRequest: CreateMaterialCategoryRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MaterialCategory>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createMaterialCategory(createMaterialCategoryRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MaterialCategoriesApi.createMaterialCategory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete an existing price book material category
         * @summary Delete Material Category
         * @param {string} uuid UUID of the material category to be updated.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteMaterialCategory(uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MaterialCategory>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteMaterialCategory(uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MaterialCategoriesApi.deleteMaterialCategory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all price book material categories from root or under a parent category
         * @summary Get Material Categories
         * @param {string} [parentUuid] Including the UUID of a specific material category will fetch all material categories that reside under that category. Not including a UUID will fetch all root level categories.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async indexMaterialCategories(parentUuid?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IndexMaterialCategories200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.indexMaterialCategories(parentUuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MaterialCategoriesApi.indexMaterialCategories']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update information of an existing price book material category
         * @summary Update Material Category
         * @param {string} uuid UUID of the material category to be updated.
         * @param {PostTagsRequest} postTagsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateMaterialCategory(uuid: string, postTagsRequest: PostTagsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MaterialCategory>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateMaterialCategory(uuid, postTagsRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MaterialCategoriesApi.updateMaterialCategory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MaterialCategoriesApi - factory interface
 * @export
 */
export const MaterialCategoriesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MaterialCategoriesApiFp(configuration)
    return {
        /**
         * Create a new price book material category
         * @summary Create Material Category
         * @param {CreateMaterialCategoryRequest} createMaterialCategoryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMaterialCategory(createMaterialCategoryRequest: CreateMaterialCategoryRequest, options?: RawAxiosRequestConfig): AxiosPromise<MaterialCategory> {
            return localVarFp.createMaterialCategory(createMaterialCategoryRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an existing price book material category
         * @summary Delete Material Category
         * @param {string} uuid UUID of the material category to be updated.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMaterialCategory(uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<MaterialCategory> {
            return localVarFp.deleteMaterialCategory(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all price book material categories from root or under a parent category
         * @summary Get Material Categories
         * @param {string} [parentUuid] Including the UUID of a specific material category will fetch all material categories that reside under that category. Not including a UUID will fetch all root level categories.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        indexMaterialCategories(parentUuid?: string, options?: RawAxiosRequestConfig): AxiosPromise<IndexMaterialCategories200Response> {
            return localVarFp.indexMaterialCategories(parentUuid, options).then((request) => request(axios, basePath));
        },
        /**
         * Update information of an existing price book material category
         * @summary Update Material Category
         * @param {string} uuid UUID of the material category to be updated.
         * @param {PostTagsRequest} postTagsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMaterialCategory(uuid: string, postTagsRequest: PostTagsRequest, options?: RawAxiosRequestConfig): AxiosPromise<MaterialCategory> {
            return localVarFp.updateMaterialCategory(uuid, postTagsRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MaterialCategoriesApi - object-oriented interface
 * @export
 * @class MaterialCategoriesApi
 * @extends {BaseAPI}
 */
export class MaterialCategoriesApi extends BaseAPI {
    /**
     * Create a new price book material category
     * @summary Create Material Category
     * @param {CreateMaterialCategoryRequest} createMaterialCategoryRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MaterialCategoriesApi
     */
    public createMaterialCategory(createMaterialCategoryRequest: CreateMaterialCategoryRequest, options?: RawAxiosRequestConfig) {
        return MaterialCategoriesApiFp(this.configuration).createMaterialCategory(createMaterialCategoryRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an existing price book material category
     * @summary Delete Material Category
     * @param {string} uuid UUID of the material category to be updated.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MaterialCategoriesApi
     */
    public deleteMaterialCategory(uuid: string, options?: RawAxiosRequestConfig) {
        return MaterialCategoriesApiFp(this.configuration).deleteMaterialCategory(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all price book material categories from root or under a parent category
     * @summary Get Material Categories
     * @param {string} [parentUuid] Including the UUID of a specific material category will fetch all material categories that reside under that category. Not including a UUID will fetch all root level categories.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MaterialCategoriesApi
     */
    public indexMaterialCategories(parentUuid?: string, options?: RawAxiosRequestConfig) {
        return MaterialCategoriesApiFp(this.configuration).indexMaterialCategories(parentUuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update information of an existing price book material category
     * @summary Update Material Category
     * @param {string} uuid UUID of the material category to be updated.
     * @param {PostTagsRequest} postTagsRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MaterialCategoriesApi
     */
    public updateMaterialCategory(uuid: string, postTagsRequest: PostTagsRequest, options?: RawAxiosRequestConfig) {
        return MaterialCategoriesApiFp(this.configuration).updateMaterialCategory(uuid, postTagsRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MaterialsApi - axios parameter creator
 * @export
 */
export const MaterialsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new price book material
         * @summary Create Material
         * @param {string} materialCategoryUuid UUID of the material category to create this material under
         * @param {CreateMaterialRequest} createMaterialRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMaterial: async (materialCategoryUuid: string, createMaterialRequest: CreateMaterialRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'materialCategoryUuid' is not null or undefined
            assertParamExists('createMaterial', 'materialCategoryUuid', materialCategoryUuid)
            // verify required parameter 'createMaterialRequest' is not null or undefined
            assertParamExists('createMaterial', 'createMaterialRequest', createMaterialRequest)
            const localVarPath = `/api/price_book/materials`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CompanyAPIKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication HousecallUserOAuthToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "HousecallUserOAuthToken", [], configuration)

            if (materialCategoryUuid !== undefined) {
                localVarQueryParameter['material_category_uuid'] = materialCategoryUuid;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createMaterialRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an existing price book material
         * @summary Delete Material
         * @param {string} uuid UUID of the material to be updated.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMaterial: async (uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('deleteMaterial', 'uuid', uuid)
            const localVarPath = `/api/price_book/materials/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CompanyAPIKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication HousecallUserOAuthToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "HousecallUserOAuthToken", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all price book materials under a parent category
         * @summary Get Materials
         * @param {string} materialCategoryUuid UUID of the material category to fetch materials under
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        indexMaterials: async (materialCategoryUuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'materialCategoryUuid' is not null or undefined
            assertParamExists('indexMaterials', 'materialCategoryUuid', materialCategoryUuid)
            const localVarPath = `/api/price_book/materials`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CompanyAPIKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication HousecallUserOAuthToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "HousecallUserOAuthToken", [], configuration)

            if (materialCategoryUuid !== undefined) {
                localVarQueryParameter['material_category_uuid'] = materialCategoryUuid;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update information of an existing price book material
         * @summary Update Material
         * @param {string} uuid UUID of the material to be updated.
         * @param {UpdateMaterialRequest} updateMaterialRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMaterial: async (uuid: string, updateMaterialRequest: UpdateMaterialRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('updateMaterial', 'uuid', uuid)
            // verify required parameter 'updateMaterialRequest' is not null or undefined
            assertParamExists('updateMaterial', 'updateMaterialRequest', updateMaterialRequest)
            const localVarPath = `/api/price_book/materials/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CompanyAPIKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication HousecallUserOAuthToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "HousecallUserOAuthToken", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateMaterialRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MaterialsApi - functional programming interface
 * @export
 */
export const MaterialsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MaterialsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new price book material
         * @summary Create Material
         * @param {string} materialCategoryUuid UUID of the material category to create this material under
         * @param {CreateMaterialRequest} createMaterialRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createMaterial(materialCategoryUuid: string, createMaterialRequest: CreateMaterialRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Material>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createMaterial(materialCategoryUuid, createMaterialRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MaterialsApi.createMaterial']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete an existing price book material
         * @summary Delete Material
         * @param {string} uuid UUID of the material to be updated.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteMaterial(uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Material>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteMaterial(uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MaterialsApi.deleteMaterial']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all price book materials under a parent category
         * @summary Get Materials
         * @param {string} materialCategoryUuid UUID of the material category to fetch materials under
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async indexMaterials(materialCategoryUuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IndexMaterials200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.indexMaterials(materialCategoryUuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MaterialsApi.indexMaterials']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update information of an existing price book material
         * @summary Update Material
         * @param {string} uuid UUID of the material to be updated.
         * @param {UpdateMaterialRequest} updateMaterialRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateMaterial(uuid: string, updateMaterialRequest: UpdateMaterialRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Material>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateMaterial(uuid, updateMaterialRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MaterialsApi.updateMaterial']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MaterialsApi - factory interface
 * @export
 */
export const MaterialsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MaterialsApiFp(configuration)
    return {
        /**
         * Create a new price book material
         * @summary Create Material
         * @param {string} materialCategoryUuid UUID of the material category to create this material under
         * @param {CreateMaterialRequest} createMaterialRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMaterial(materialCategoryUuid: string, createMaterialRequest: CreateMaterialRequest, options?: RawAxiosRequestConfig): AxiosPromise<Material> {
            return localVarFp.createMaterial(materialCategoryUuid, createMaterialRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an existing price book material
         * @summary Delete Material
         * @param {string} uuid UUID of the material to be updated.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMaterial(uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<Material> {
            return localVarFp.deleteMaterial(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all price book materials under a parent category
         * @summary Get Materials
         * @param {string} materialCategoryUuid UUID of the material category to fetch materials under
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        indexMaterials(materialCategoryUuid: string, options?: RawAxiosRequestConfig): AxiosPromise<IndexMaterials200Response> {
            return localVarFp.indexMaterials(materialCategoryUuid, options).then((request) => request(axios, basePath));
        },
        /**
         * Update information of an existing price book material
         * @summary Update Material
         * @param {string} uuid UUID of the material to be updated.
         * @param {UpdateMaterialRequest} updateMaterialRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMaterial(uuid: string, updateMaterialRequest: UpdateMaterialRequest, options?: RawAxiosRequestConfig): AxiosPromise<Material> {
            return localVarFp.updateMaterial(uuid, updateMaterialRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MaterialsApi - object-oriented interface
 * @export
 * @class MaterialsApi
 * @extends {BaseAPI}
 */
export class MaterialsApi extends BaseAPI {
    /**
     * Create a new price book material
     * @summary Create Material
     * @param {string} materialCategoryUuid UUID of the material category to create this material under
     * @param {CreateMaterialRequest} createMaterialRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MaterialsApi
     */
    public createMaterial(materialCategoryUuid: string, createMaterialRequest: CreateMaterialRequest, options?: RawAxiosRequestConfig) {
        return MaterialsApiFp(this.configuration).createMaterial(materialCategoryUuid, createMaterialRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an existing price book material
     * @summary Delete Material
     * @param {string} uuid UUID of the material to be updated.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MaterialsApi
     */
    public deleteMaterial(uuid: string, options?: RawAxiosRequestConfig) {
        return MaterialsApiFp(this.configuration).deleteMaterial(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all price book materials under a parent category
     * @summary Get Materials
     * @param {string} materialCategoryUuid UUID of the material category to fetch materials under
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MaterialsApi
     */
    public indexMaterials(materialCategoryUuid: string, options?: RawAxiosRequestConfig) {
        return MaterialsApiFp(this.configuration).indexMaterials(materialCategoryUuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update information of an existing price book material
     * @summary Update Material
     * @param {string} uuid UUID of the material to be updated.
     * @param {UpdateMaterialRequest} updateMaterialRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MaterialsApi
     */
    public updateMaterial(uuid: string, updateMaterialRequest: UpdateMaterialRequest, options?: RawAxiosRequestConfig) {
        return MaterialsApiFp(this.configuration).updateMaterial(uuid, updateMaterialRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OptionsApi - axios parameter creator
 * @export
 */
export const OptionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new estimate option attachment
         * @summary Create Estimate option attachment
         * @param {string} estimateId 
         * @param {string} optionId 
         * @param {File} file A binary file from your local machine
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEstimateOptionAttachment: async (estimateId: string, optionId: string, file: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'estimateId' is not null or undefined
            assertParamExists('createEstimateOptionAttachment', 'estimateId', estimateId)
            // verify required parameter 'optionId' is not null or undefined
            assertParamExists('createEstimateOptionAttachment', 'optionId', optionId)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('createEstimateOptionAttachment', 'file', file)
            const localVarPath = `/estimates/{estimate_id}/options/{option_id}/attachments`
                .replace(`{${"estimate_id"}}`, encodeURIComponent(String(estimateId)))
                .replace(`{${"option_id"}}`, encodeURIComponent(String(optionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication CompanyAPIKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication HousecallUserOAuthToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "HousecallUserOAuthToken", [], configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OptionsApi - functional programming interface
 * @export
 */
export const OptionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OptionsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new estimate option attachment
         * @summary Create Estimate option attachment
         * @param {string} estimateId 
         * @param {string} optionId 
         * @param {File} file A binary file from your local machine
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEstimateOptionAttachment(estimateId: string, optionId: string, file: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateEstimateOptionAttachment202Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEstimateOptionAttachment(estimateId, optionId, file, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OptionsApi.createEstimateOptionAttachment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * OptionsApi - factory interface
 * @export
 */
export const OptionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OptionsApiFp(configuration)
    return {
        /**
         * Create a new estimate option attachment
         * @summary Create Estimate option attachment
         * @param {string} estimateId 
         * @param {string} optionId 
         * @param {File} file A binary file from your local machine
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEstimateOptionAttachment(estimateId: string, optionId: string, file: File, options?: RawAxiosRequestConfig): AxiosPromise<CreateEstimateOptionAttachment202Response> {
            return localVarFp.createEstimateOptionAttachment(estimateId, optionId, file, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OptionsApi - object-oriented interface
 * @export
 * @class OptionsApi
 * @extends {BaseAPI}
 */
export class OptionsApi extends BaseAPI {
    /**
     * Create a new estimate option attachment
     * @summary Create Estimate option attachment
     * @param {string} estimateId 
     * @param {string} optionId 
     * @param {File} file A binary file from your local machine
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OptionsApi
     */
    public createEstimateOptionAttachment(estimateId: string, optionId: string, file: File, options?: RawAxiosRequestConfig) {
        return OptionsApiFp(this.configuration).createEstimateOptionAttachment(estimateId, optionId, file, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ScheduleApi - axios parameter creator
 * @export
 */
export const ScheduleApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * See how an organization has configured their business hours and bookable windows.
         * @summary Schedule Windows
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCompanyScheduleAvailability: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/company/schedule_availability`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApplicationAPIKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication CompanyAPIKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication HousecallUserOAuthToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "HousecallUserOAuthToken", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * See the actual available windows to book a job or estimate for a given time range (default 7 days). Booking availability is based on how the organization has configured Online Booking settings, as well as actual open time slots per employee.
         * @summary Booking Windows
         * @param {string} [showForDays] An integer value that dictates how many days of the schedule should be shown; defaults to 7
         * @param {string} [startDate] A date string formatted like \&#39;YYYY-MM-DD\&#39;; defaults to the next day with an available booking window
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCompanyScheduleBookingWindowsAvailability: async (showForDays?: string, startDate?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/company/schedule_availability/booking_windows`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApplicationAPIKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication CompanyAPIKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication HousecallUserOAuthToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "HousecallUserOAuthToken", [], configuration)

            if (showForDays !== undefined) {
                localVarQueryParameter['show_for_days'] = showForDays;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = startDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a company\'s schedule windows
         * @param {UpdateCompleteScheduleAvailability} [updateCompleteScheduleAvailability] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCompanyScheduleAvailability: async (updateCompleteScheduleAvailability?: UpdateCompleteScheduleAvailability, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/company/schedule_availability`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApplicationAPIKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication CompanyAPIKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication HousecallUserOAuthToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "HousecallUserOAuthToken", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateCompleteScheduleAvailability, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ScheduleApi - functional programming interface
 * @export
 */
export const ScheduleApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ScheduleApiAxiosParamCreator(configuration)
    return {
        /**
         * See how an organization has configured their business hours and bookable windows.
         * @summary Schedule Windows
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCompanyScheduleAvailability(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CompleteScheduleAvailability>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCompanyScheduleAvailability(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScheduleApi.getCompanyScheduleAvailability']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * See the actual available windows to book a job or estimate for a given time range (default 7 days). Booking availability is based on how the organization has configured Online Booking settings, as well as actual open time slots per employee.
         * @summary Booking Windows
         * @param {string} [showForDays] An integer value that dictates how many days of the schedule should be shown; defaults to 7
         * @param {string} [startDate] A date string formatted like \&#39;YYYY-MM-DD\&#39;; defaults to the next day with an available booking window
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCompanyScheduleBookingWindowsAvailability(showForDays?: string, startDate?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BookingWindows>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCompanyScheduleBookingWindowsAvailability(showForDays, startDate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScheduleApi.getCompanyScheduleBookingWindowsAvailability']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a company\'s schedule windows
         * @param {UpdateCompleteScheduleAvailability} [updateCompleteScheduleAvailability] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCompanyScheduleAvailability(updateCompleteScheduleAvailability?: UpdateCompleteScheduleAvailability, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CompleteScheduleAvailability>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCompanyScheduleAvailability(updateCompleteScheduleAvailability, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScheduleApi.updateCompanyScheduleAvailability']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ScheduleApi - factory interface
 * @export
 */
export const ScheduleApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ScheduleApiFp(configuration)
    return {
        /**
         * See how an organization has configured their business hours and bookable windows.
         * @summary Schedule Windows
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCompanyScheduleAvailability(options?: RawAxiosRequestConfig): AxiosPromise<CompleteScheduleAvailability> {
            return localVarFp.getCompanyScheduleAvailability(options).then((request) => request(axios, basePath));
        },
        /**
         * See the actual available windows to book a job or estimate for a given time range (default 7 days). Booking availability is based on how the organization has configured Online Booking settings, as well as actual open time slots per employee.
         * @summary Booking Windows
         * @param {string} [showForDays] An integer value that dictates how many days of the schedule should be shown; defaults to 7
         * @param {string} [startDate] A date string formatted like \&#39;YYYY-MM-DD\&#39;; defaults to the next day with an available booking window
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCompanyScheduleBookingWindowsAvailability(showForDays?: string, startDate?: string, options?: RawAxiosRequestConfig): AxiosPromise<BookingWindows> {
            return localVarFp.getCompanyScheduleBookingWindowsAvailability(showForDays, startDate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a company\'s schedule windows
         * @param {UpdateCompleteScheduleAvailability} [updateCompleteScheduleAvailability] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCompanyScheduleAvailability(updateCompleteScheduleAvailability?: UpdateCompleteScheduleAvailability, options?: RawAxiosRequestConfig): AxiosPromise<CompleteScheduleAvailability> {
            return localVarFp.updateCompanyScheduleAvailability(updateCompleteScheduleAvailability, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ScheduleApi - object-oriented interface
 * @export
 * @class ScheduleApi
 * @extends {BaseAPI}
 */
export class ScheduleApi extends BaseAPI {
    /**
     * See how an organization has configured their business hours and bookable windows.
     * @summary Schedule Windows
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScheduleApi
     */
    public getCompanyScheduleAvailability(options?: RawAxiosRequestConfig) {
        return ScheduleApiFp(this.configuration).getCompanyScheduleAvailability(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * See the actual available windows to book a job or estimate for a given time range (default 7 days). Booking availability is based on how the organization has configured Online Booking settings, as well as actual open time slots per employee.
     * @summary Booking Windows
     * @param {string} [showForDays] An integer value that dictates how many days of the schedule should be shown; defaults to 7
     * @param {string} [startDate] A date string formatted like \&#39;YYYY-MM-DD\&#39;; defaults to the next day with an available booking window
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScheduleApi
     */
    public getCompanyScheduleBookingWindowsAvailability(showForDays?: string, startDate?: string, options?: RawAxiosRequestConfig) {
        return ScheduleApiFp(this.configuration).getCompanyScheduleBookingWindowsAvailability(showForDays, startDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a company\'s schedule windows
     * @param {UpdateCompleteScheduleAvailability} [updateCompleteScheduleAvailability] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScheduleApi
     */
    public updateCompanyScheduleAvailability(updateCompleteScheduleAvailability?: UpdateCompleteScheduleAvailability, options?: RawAxiosRequestConfig) {
        return ScheduleApiFp(this.configuration).updateCompanyScheduleAvailability(updateCompleteScheduleAvailability, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TagsApi - axios parameter creator
 * @export
 */
export const TagsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get a list of tags
         * @summary Get tags
         * @param {number} [page] Current Page
         * @param {number} [pageSize] Number of tags per page
         * @param {GetTagsSortByEnum} [sortBy] Tag attribute to sort by
         * @param {GetTagsSortDirectionEnum} [sortDirection] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTags: async (page?: number, pageSize?: number, sortBy?: GetTagsSortByEnum, sortDirection?: GetTagsSortDirectionEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/tags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApplicationAPIKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication CompanyAPIKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication HousecallUserOAuthToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "HousecallUserOAuthToken", [], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (sortDirection !== undefined) {
                localVarQueryParameter['sort_direction'] = sortDirection;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a tag
         * @summary Create a tag
         * @param {PostTagsRequest} [postTagsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTags: async (postTagsRequest?: PostTagsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/tags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApplicationAPIKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication CompanyAPIKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication HousecallUserOAuthToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "HousecallUserOAuthToken", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postTagsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a tag value
         * @summary Update a tag
         * @param {string} tagId 
         * @param {PostTagsRequest} [postTagsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putTagsTagId: async (tagId: string, postTagsRequest?: PostTagsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tagId' is not null or undefined
            assertParamExists('putTagsTagId', 'tagId', tagId)
            const localVarPath = `/tags/{tag_id}`
                .replace(`{${"tag_id"}}`, encodeURIComponent(String(tagId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApplicationAPIKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication CompanyAPIKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication HousecallUserOAuthToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "HousecallUserOAuthToken", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postTagsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TagsApi - functional programming interface
 * @export
 */
export const TagsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TagsApiAxiosParamCreator(configuration)
    return {
        /**
         * Get a list of tags
         * @summary Get tags
         * @param {number} [page] Current Page
         * @param {number} [pageSize] Number of tags per page
         * @param {GetTagsSortByEnum} [sortBy] Tag attribute to sort by
         * @param {GetTagsSortDirectionEnum} [sortDirection] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTags(page?: number, pageSize?: number, sortBy?: GetTagsSortByEnum, sortDirection?: GetTagsSortDirectionEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetTags200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTags(page, pageSize, sortBy, sortDirection, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TagsApi.getTags']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a tag
         * @summary Create a tag
         * @param {PostTagsRequest} [postTagsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postTags(postTagsRequest?: PostTagsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postTags(postTagsRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TagsApi.postTags']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update a tag value
         * @summary Update a tag
         * @param {string} tagId 
         * @param {PostTagsRequest} [postTagsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putTagsTagId(tagId: string, postTagsRequest?: PostTagsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putTagsTagId(tagId, postTagsRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TagsApi.putTagsTagId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TagsApi - factory interface
 * @export
 */
export const TagsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TagsApiFp(configuration)
    return {
        /**
         * Get a list of tags
         * @summary Get tags
         * @param {number} [page] Current Page
         * @param {number} [pageSize] Number of tags per page
         * @param {GetTagsSortByEnum} [sortBy] Tag attribute to sort by
         * @param {GetTagsSortDirectionEnum} [sortDirection] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTags(page?: number, pageSize?: number, sortBy?: GetTagsSortByEnum, sortDirection?: GetTagsSortDirectionEnum, options?: RawAxiosRequestConfig): AxiosPromise<GetTags200Response> {
            return localVarFp.getTags(page, pageSize, sortBy, sortDirection, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a tag
         * @summary Create a tag
         * @param {PostTagsRequest} [postTagsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTags(postTagsRequest?: PostTagsRequest, options?: RawAxiosRequestConfig): AxiosPromise<Tag> {
            return localVarFp.postTags(postTagsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a tag value
         * @summary Update a tag
         * @param {string} tagId 
         * @param {PostTagsRequest} [postTagsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putTagsTagId(tagId: string, postTagsRequest?: PostTagsRequest, options?: RawAxiosRequestConfig): AxiosPromise<Tag> {
            return localVarFp.putTagsTagId(tagId, postTagsRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TagsApi - object-oriented interface
 * @export
 * @class TagsApi
 * @extends {BaseAPI}
 */
export class TagsApi extends BaseAPI {
    /**
     * Get a list of tags
     * @summary Get tags
     * @param {number} [page] Current Page
     * @param {number} [pageSize] Number of tags per page
     * @param {GetTagsSortByEnum} [sortBy] Tag attribute to sort by
     * @param {GetTagsSortDirectionEnum} [sortDirection] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public getTags(page?: number, pageSize?: number, sortBy?: GetTagsSortByEnum, sortDirection?: GetTagsSortDirectionEnum, options?: RawAxiosRequestConfig) {
        return TagsApiFp(this.configuration).getTags(page, pageSize, sortBy, sortDirection, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a tag
     * @summary Create a tag
     * @param {PostTagsRequest} [postTagsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public postTags(postTagsRequest?: PostTagsRequest, options?: RawAxiosRequestConfig) {
        return TagsApiFp(this.configuration).postTags(postTagsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a tag value
     * @summary Update a tag
     * @param {string} tagId 
     * @param {PostTagsRequest} [postTagsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public putTagsTagId(tagId: string, postTagsRequest?: PostTagsRequest, options?: RawAxiosRequestConfig) {
        return TagsApiFp(this.configuration).putTagsTagId(tagId, postTagsRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const GetTagsSortByEnum = {
    CreatedAt: 'created_at',
    Name: 'name'
} as const;
export type GetTagsSortByEnum = typeof GetTagsSortByEnum[keyof typeof GetTagsSortByEnum];
/**
 * @export
 */
export const GetTagsSortDirectionEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type GetTagsSortDirectionEnum = typeof GetTagsSortDirectionEnum[keyof typeof GetTagsSortDirectionEnum];


/**
 * WebhooksApi - axios parameter creator
 * @export
 */
export const WebhooksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete a company\'s webhook subciption to stop receiving events for that company.
         * @summary Delete a Webhook Subscription
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWebhooksSubscribe: async (body?: object, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/webhooks/subscription`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Webhooks are disabled by default and need to be subscribed for each company individually. Once subscribed, you will begin to receive events for the company on your webhook endpoint.
         * @summary Create a Webhook Subscription
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postWebhooksSubscribe: async (body?: object, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/webhooks/subscription`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WebhooksApi - functional programming interface
 * @export
 */
export const WebhooksApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WebhooksApiAxiosParamCreator(configuration)
    return {
        /**
         * Delete a company\'s webhook subciption to stop receiving events for that company.
         * @summary Delete a Webhook Subscription
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteWebhooksSubscribe(body?: object, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteWebhooksSubscribe(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhooksApi.deleteWebhooksSubscribe']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Webhooks are disabled by default and need to be subscribed for each company individually. Once subscribed, you will begin to receive events for the company on your webhook endpoint.
         * @summary Create a Webhook Subscription
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postWebhooksSubscribe(body?: object, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postWebhooksSubscribe(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhooksApi.postWebhooksSubscribe']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * WebhooksApi - factory interface
 * @export
 */
export const WebhooksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WebhooksApiFp(configuration)
    return {
        /**
         * Delete a company\'s webhook subciption to stop receiving events for that company.
         * @summary Delete a Webhook Subscription
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWebhooksSubscribe(body?: object, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteWebhooksSubscribe(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Webhooks are disabled by default and need to be subscribed for each company individually. Once subscribed, you will begin to receive events for the company on your webhook endpoint.
         * @summary Create a Webhook Subscription
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postWebhooksSubscribe(body?: object, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.postWebhooksSubscribe(body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WebhooksApi - object-oriented interface
 * @export
 * @class WebhooksApi
 * @extends {BaseAPI}
 */
export class WebhooksApi extends BaseAPI {
    /**
     * Delete a company\'s webhook subciption to stop receiving events for that company.
     * @summary Delete a Webhook Subscription
     * @param {object} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public deleteWebhooksSubscribe(body?: object, options?: RawAxiosRequestConfig) {
        return WebhooksApiFp(this.configuration).deleteWebhooksSubscribe(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Webhooks are disabled by default and need to be subscribed for each company individually. Once subscribed, you will begin to receive events for the company on your webhook endpoint.
     * @summary Create a Webhook Subscription
     * @param {object} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public postWebhooksSubscribe(body?: object, options?: RawAxiosRequestConfig) {
        return WebhooksApiFp(this.configuration).postWebhooksSubscribe(body, options).then((request) => request(this.axios, this.basePath));
    }
}



